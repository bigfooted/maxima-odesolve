/* ************************************************************************** */
/* *****     prellesingeODE                                             ***** */
/* *****                                                                ***** */ 
/* *****     Author: Nijso Beishuizen                                   ***** */ 
/* *****                                                                ***** */
/* *****     PRELLE-SINGER METHOD FOR SOLVING FIRST ORDER ODES          ***** */
/* *****     Based on the paper                                         ***** */
/* *****     Y.K. Man - Computing closed form solutions of first order  ***** */
/* *****                ODEs using the Prelle-Singer procedure          ***** */
/* *****     Journal of Symbolic Computation 16 (1993) pp. 423-443      ***** */
/* *****     and the work of                                            ***** */  
/* *****     R. Shtokhamer - Solving first order differential equations ***** */  
/* *****                     using the Prelle-Singer algorithm          ***** */
/* *****     Technical Report 88-09, May 1988                           ***** */
/* *****     and the work of                                            ***** */
/* *****     J. Avellar, L.G.S. Duarte, S.E.S. Duarte, L.A.C.P. la Mota ***** */ 
/* *****     Determining Liouvillian first integrals for dynamical      ***** */ 
/* *****     systems in the plane                                       ***** */ 
/* *****                                                                ***** */ 
/* *****                                                                ***** */
/* ************************************************************************** */
/* ************************************************************************** */

/* ************************************************************************** */
put('prellesinger,001,'version)$
/* ************************************************************************** */

/* ***** print all statements with flag lower than DEBUGFLAG           ***** */
DEBUGFLAG:5$


load(lrats)$   /* for lratsubst */
load(grobner)$ /* for computing grobner basis              */
load(functs)$  /* for the least common multiple command lcm */
define_variable(degreeboundf, 2, fixnum)$ /* max degree of trial polynomials for the invariant algebraic curves (realistic is 1-4) */
define_variable(degreeboundP, 4, fixnum)$ /* max degree of trial polynomials for exponential factors(realistic is 1-4) */
define_variable(degreeboundQ, 4, fixnum)$ /* max degree of trial polynomials for exponential factors(realistic is 1-4) */
define_variable(ODEFI_GRAD_LIST    ,[]    ,any)$ /* not used (yet), copied from Shtokhamer's code */
define_variable(convertImaginary,true, boolean)$ /* try to convert imaginary numbers to real numbers */
define_variable(heuristics,true, boolean)$       /* try to use a heuristic method for solving the ode (linear, separable, etc) */
define_variable(convertTrig,true, boolean)$      /* convert trig functions (sin,cos,csc,sec,cot) to tan  */

halfangles : true$   /* converts trigonometric halfangles, i.e. tan(x/2), sin(x/2), etc    */
%edispflag : true$   /* writes negative powers of %e as a quotient, i.e. %e^-x  ->  1/%e^x */
exptdispflag : true$ /* writes exponents with negative powers as quotients                 */


/* ************************************************************************** */
/* *****    MAIN ROUTINE                                                ***** */
/* *****    INPUT: ode of the form P(x,y)*'diff(y,x)= Q(x,y)            ***** */
/* *****           y = dependent variable, x = independent variable     ***** */
/* *****    OUTPUT: solution of the ODE, or false                       ***** */
/* ************************************************************************** */
prellesingerODE(_ode1,_y,_x,[options]):=block(
  [varlist, Sfg:[],_k,fList,%Ci,Sum_nigi:0,niList:[],firstIntegral:1,feqns,
   dx,dy,ddx,ddy,denom_lcm,dPdx_plus_dQdy,constantlist,method:false,_mu:false,
   denom_lcm:1,ExponentialFactors:[1],DarbouxPolynomials:[]],

  dprint(1,""),
  dprint(1,"----------------------------------------------------------------------------"), 
  dprint(1,"--- Prelle-Singer method for first order ordinary differential equations ---"),
  dprint(1,"----------------------------------------------------------------------------"),
  dprint(1,""),

  /* --- check all the optional arguments --- */
  heuristics               : assoc('heuristics,options,true),               /* if true, then first try a number of fast specialized solvers for e.g. linear odes. */
  searchExponentialFactors : assoc('searchExponentialFactors,options,true), /* if true, then also search for exponential factors */
  convertImaginary         : assoc('convertImaginary,options,true),         /* if true, convert imaginary numbers to real to simplify integrating factor. true if input ODE does not contain %i */
  searchRational           : assoc('searchRational,options,false),          /* if true, only search for rational solutions */
  /*searchDarboux            : assoc('searchDarboux,options,false),*/       /* if true, only search (and return) the Darboux polynomials and cofactors */
  convertTrig		   : assoc('convertTrig,options,true),              /* if true, convert (sin,cos,csc,sec,cot) functions to tan to create a true transcendence base */
  basisFunctions           : assoc('basisFunctions,options,[]),             /* user-defined lexicographically ordered list of basis functions */

  dprint(1,""),
  dprint(1,"---------- optional arguments : -----------------------------"),
  dprint(1,"---------- use heuristics                  = ",heuristics),
  dprint(1,"---------- user defined basis functions    = ",basisFunctions),
  dprint(1,"---------- search only rational solutions  = ",searchRational),
  dprint(1,"---------- search for exponential factors  = ",searchExponentialFactors),
  dprint(1,"---------- convert imaginary to real       = ",convertImaginary),
  dprint(1,"---------- convert trig functions to tan   = ",convertTrig),
  dprint(1,"------------------------------------------------------------"),
  dprint(1,""),

  /* check if input is a first order ode */
  _type: odeType(_ode1,_y,_x,'firstorder),
  dprint(3,"type = ",_type),
  if _type=false then return(false),

  /* rewrite the ode to canonical form */
  dprint(3,"ode = ",_ode1),
  _ode: ode1CanonicalForm(_ode1,_y,_x),
  dprint(3,"canonical form of ode = ",_ode),

  /* convert sin,cos, csc,sec,cot to t=tan(x/2), u=tan(y/2) */
  if (convertTrig=true) then (
    _ode:Trig2T(_ode,_x,_y,_t,_u),
    dprint(3,"ode = ",_ode),

    apply('gradef,[_t,_x,(_t^2+1)/2]),
    apply('gradef,[_t,_y,0]),

    apply('gradef,[_u,_x,0]),
    apply('gradef,[_u,_y,(_u^2+1)/2])
  ), 
  
  [_P,_Q] : ode1PfaffianForm(_ode,_y,_x),
  dprint(3,"P = ",_P), 
  dprint(3,"Q = ",_Q),


    /* deal with user-defined substitution rules */
/*
    if ODEFI_GRAD_LIST # nil then (
      ODEFI_GRAD_LIST:subst(%x2,_x,subst(%x1,_y,ODEFI_GRAD_LIST)), 
      for _dfs in ODEFI_GRAD_LIST do (
        _df:lhs(_dfs),
        _df_x:diff(_df,_x),
        _df_y:diff(_df,_y), 
        if _df_x#0 or _df_y#0 then (
          apply('gradef,[_df,%x2,subst(%x2,_x,subst(%x1,_y,_df_x))]), 
          apply('gradef,[_df,%x1,subst(%x2,_x,subst(%x1,_y,_df_y))]) 
        ) 
      )
    ),
*/
  
  /* check heuristic methods to solve first order ode */
  if (heuristics=true) then 
    [method,_mu] : specialintfactor(_Q,_P,_y,_x),

  /* if we do not have an integrating factor yet, try the prelle singer method */
  if (method=false) then 
    [method,DarbouxPolynomials,DarbouxMultiplicities,ExponentialFactors] : new_ps_1(_P,_Q,_y,_x,basisFunctions),
  if method=false then return(false), 

  /* back-substitution of temporary trig-substitution */ 
  if (convertTrig=true) then (
    DarbouxPolynomials : T2Trig(DarbouxPolynomials,_x,_y,_t,_u),
    ExponentialFactors : T2Trig(ExponentialFactors,_x,_y,_t,_u),
    
    _P : T2Trig(_P,_x,_y,_t,_u),
    _Q : T2Trig(_Q,_x,_y,_t,_u),
    /* we might get trivial polynomials because of trig identities. We will remove them */
    indices : sublist_indices(DarbouxPolynomials,lambda([_i],not lfreeof([_x,_y],_i) )),
    DarbouxPolynomials : makelist(DarbouxPolynomials[i],i,indices), 
    DarbouxMultiplicities : makelist(DarbouxMultiplicities[i],i,indices) 
  ),
  dprint(3,"P = ",_P), 
  dprint(3,"Q = ",_Q),
  dprint(3,"method = ",method),
  dprint(1,"Darbouxpolynomials,cofactors = ",DarbouxPolynomials),
  dprint(3,"Darbouxpolynomials = ",grind(DarbouxPolynomials)),
  dprint(3,"DarbouxMultiplicities = ",grind(DarbouxMultiplicities)),

  if (method="Darboux" or method="integratingFactor") then 
    _mu : DarbouxIntegratingFactor(DarbouxPolynomials,DarbouxMultiplicities,ExponentialFactors),


  if method="firstIntegral" then ( 
    dprint(3,"FIRST INTEGRAL FOUND"),
    sol: rootscontract(_mu) - %c 
  ) 
  else ( 
    sol : ode1Solve(_P,_Q,_y,_x,'integratingFactor=_mu) 
  ),

  sol: cleanupODESolution(sol,_y,_x),

  dprint(3,"solution = ",grind(sol)),
  return(sol)
)$
/* ************************************************************************** */


ode1Solve(_P,_Q,_y,_x,[options]):=block([_check,_res,_mu:false,mu_P,mu_Q,exactode,_N,_M,res1,res2,sol],

  /* --- check all the optional arguments --- */
  _mu		   : assoc('integratingFactor,options,[]),                

  dprint(3,""),
  dprint(3,"---------- optional arguments : -----------------------------"),
  dprint(3,"---------- use integrating factor        = ",_mu),
  dprint(3,""),

  if _mu=false then (
    dprint(0,"only integrating factor is implemented!"),
    return(false)
  ),

  _P : rootscontract(_P),_Q:rootscontract(_Q), /* the simplification to canonical could introduce imaginary numbers when square roots are in the expression */

  dprint(3,"P = ",grind(_P)), 
  dprint(3,"Q = ",grind(_Q)),

  _mu: ratsimp(trigsimp(_mu)),
  /* rootscontract converts products of roots into roots of products, simplifies an expression like 1/(sqrt(x-%i)sqrt(x+%i)) = 1/(sqrt(x^2+1)) */
  /* note that abs(x) can also be put into the root when x is real*/
  _mu: rootscontract(_mu),

  /* we try to get rid of imaginary numbers */
  mu_P : num(_mu),
  mu_Q : denom(_mu),
  if not freeof(%i,mu_P) and (convertImaginary=true) then (
    mu_P : rootscontract(mu_P),
    mu_P : rectform(radcan(mu_P)), /* for simplification of e.g. -1^%i*/
    mu_P : trigreduce(trigsimp(demoivre(mu_P))) /* if mu=exp(sin(x)) then exponentialize(mu) has exploded this expression and introduced complex numbers */
  ),
  if not freeof(%i,mu_Q) and (convertImaginary=true) then (
    mu_Q : rootscontract(mu_Q),
    mu_Q : rectform(radcan(mu_Q)), /* for simplification of e.g. -1^%i*/
    mu_Q : trigreduce(trigsimp(demoivre(mu_Q))) /* if mu=exp(sin(x)) then exponentialize(mu) has exploded this expression and introduced complex numbers */
  ),

  _mu : ratsimp(trigsimp(mu_P / mu_Q)),

/*
    if not freeof(%e,_mu) then 
      _mu: radcan(exponentialize(_mu)), /* will simplify e.g. exp(log(a*x+b)) */
*/
  _mu : radcan(_mu), /* radcan will get rid of (x^a)^b*/
  dprint(3,"MU = ",grind(_mu),_y,_x),

  exactode : radcan(trigsimp(ratsimp (diff(_mu*_P,_x) + diff(_mu*_Q,_y)))), 
  dprint(3,"Does integrating factor make ODE exact?  ",grind(exactode), " ",is(exactode=0)),

  /* we integrate the exact equation. note that we can do that in two ways and we need to choose the easiest one */
  /* NB: trigsimp helps in simplifying e.g. kamke1.6, speedup from 20s to 1s !!! */
  _N : trigsimp(ratsimp(-_mu*_P)),
  _M : trigsimp(ratsimp(_mu*_Q)),
  dprint(3,"N = ",grind(_N)),
  dprint(3,"M = ",grind(_M)),
  res1: trigreduce(trigsimp(ratsimp(integrate(_M,_x)))),
  /*dprint(3,"res1 = ",res1),*/
  res1a: radcan(res1),
  /*dprint(3,"res1 = ",res1),*/
  if freeof(%i,res1) and freeof(%i,res1a) then res1:res1a,

  /*dprint(3,"res1 = ",res1),*/
  res2: trigreduce(trigsimp(ratsimp(integrate(_N,_y)))),
  res2a: radcan(res2),
  if freeof(%i,res2) and freeof(%i,res2a) then res2:res2a,

  /*dprint(3,"res2 = ",res2),*/
  sol: res1 + integrate(_N - diff(res1,_y),_y) +%c,
  dprint(3,"sol = ",sol), 

  return(sol)
)$
/* ************************************************************************** */



/* ************************************************************************** */ 
/* ************************************************************************** */ 
ode1CheckDarboux(Sfg,varlist,niList,Sum_nigi):=block(
[_allcoef, %rnum_list:[], %rnum:1, ni, nrOfNum],

  dprint(3,"ode1CheckDarboux: start"),
  dprint(3,"sum nigi = ",grind(Sum_nigi)),
  dprint(3,"varlist = ",varlist),
  _allcoef : allcoeffsNew(Sum_nigi,varlist),
  dprint(3,"_allcoef = ",_allcoef),
  dprint(3,"niList = ",niList),
  ni : flatten([solve(_allcoef,niList)]), 
 
  nrOfrnum : length(%rnum_list),
  dprint(3,"ni = ",ni),
  ni : subst(0,all,ni), /* if ni can be anything, set it to 0 (maybe we can set it to 1?)*/
  for r in %rnum_list do 
    ni:subst(0,r,ni), /* replace all free variables with 0 (cannot be another value)*/
 
/* step 3
  if length(ni)>0 and listp(ni[1]) then  
    ni : map(rhs,flatten(ni[1])), 
*/

/* step 4 */
  if (length(ni)>0) then  
    ni : map(rhs,flatten(ni)), 

/*
  if length(delete(0,ni)) # 0 then (
    EXIT : true, method: "firstIntegral",
    print(" ***** FIRST INTEGRAL FOUND ***** "), 
    return(method)
  )
*/

  dprint(3,"ode1CheckDarboux: end, ni=",ni),
  return(ni)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** new_ps_1 - prelle singer method from Y.K. Man (1993)           ***** */
/* *****            - added search for the exponential factors          ***** */
/* ************************************************************************** */
new_ps_1(_P,_Q,_y,_x,_userDefinedBasisFunctions):=block(
  [EXIT:false, realSystem:false, sol:false, integratingFactor:false,
   Sum_nigi:0, firstIntegral:1,
   Sfg:[], niList:[], exponentialFactor:[],
   varlist, _k, fList, %Ci, feqns, dx,dy,ddx,ddy, denom_lcm, dPdx_plus_dQdy, constantlist ],

  dprint(3,"P = ",_P), 
  dprint(3,"Q = ",_Q),
  dprint(3,"degreebound = ",degreeboundf),

  /* if the ode is real we set the realsystem to true. Invariant algebraic curves, cofactors and exponential factors will now be converted to */
  /* real expressions by using the complex conjugate expressions: when f is an IAC, then conj(f) is an IAC and also f*conj(f) is an AIC.      */
  /* Moreover, f*conj(f) is real. */
  if (freeof(%i,_P) and freeof(%i,_Q)) then realSystem:true,
  dprint(3,"is the ODE real: ",realSystem),
 
  /* ******************************* */
  if _userDefinedBasisFunctions = [] then 
    varlist : BasisFunctions(_P,_Q,_y,_x)
  else
    varlist : _userDefinedBasisFunctions,
  dprint(1,"basis functions = ",varlist), 
  /* ******************************* */

  /* get a list of all variables in P and Q, remove the variables in varlist and make the remaining variables a constant */
  constantlist: complement(varlist,listofvars(_Q/_P)),
  dprint(3,"detected free variables (undefined constants) in ode: ",constantlist), 
  /* (BUG) note: should remove from constantlist the constants that are already declared constant by the user! */
  apply(declare,[''constantlist,constant]), /* declare quotes its arguments so we unquote it*/

  /* ----------------------------------------------------------------------------------------------- */
  /* now replace with internal variables [x1,x2,x3,...,xn] where  x1 > x2 > x3 > x4 > ... > xn */
  /* ----------------------------------------------------------------------------------------------- */
  original_variables : varlist,
  varlist:makelist(concat(%x,i),i,1,length(varlist)), 
  dprint(3,"varlist = ",varlist),
  
  /* define varlist as ratvars, such that a*%x1 + b*a*%x1 = (a+b*a)*%x1 */
  /* (if ratvars=[a], then a*%x1+b*a*%x1) = (%x1+b*%x1)*a )             */
  /* TODO: _oldratvars : ratvars,*/ /* check if this clashes with _oldratvars elsewhere*/
  /* ratvars=varlist,*/

  /* 2. define derivatives dci/dx and dci/dy */
  dx: trigexpand(trigsimp(diff(original_variables,_x))),
  dy: trigexpand(trigsimp(diff(original_variables,_y))),
  ddx : map(denom,dx), /* take the gradient of all variables wrt y and then take the denominator */
  ddy : map(denom,dy),

  dprint(3,"dx = ",dx), 
  dprint(3,"dy = ",dy), 
  dprint(3,"ddx = ",ddx), 
  dprint(3,"ddy = ",ddy), 

/*
  if convertTrig=true then ( 
    dx : Trig2Tan(dx,_y,_x),
    dy : Trig2Tan(dy,_y,_x),
    ddx : map(denom,dx),
    ddy : map(denom,dy)
  ),
*/

  denom_lcm : lcm([ddx,ddy]), /* compute the denominator of the least common multiple */
  /* note: sometimes we first need ratexpand to get rid of some complicated fractions, before doing ratsimp */
  /*dPdx_plus_dQdy : -trigexpand(trigsimp((diff(_P,_x) + diff(_Q,_y)))) * denom_lcm, */ /* needed in step 4 */
  dPdx_plus_dQdy : -trigexpand(trigsimp((diff(_P,_x) + diff(_Q,_y)))), /* needed in step 4 */

/*  if convertTrig=true then  dPdx_plus_dQdy : Trig2Tan(dPdx_plus_dQdy,_y,_x),*/

  dprint(3,"dx = ",dx), 
  dprint(3,"dy = ",dy), 
  dprint(3,"ddx = ",ddx), 
  dprint(3,"ddy = ",ddy), 
  dprint(3,"denom_lcm = ",denom_lcm),
  dprint(3,"dP/dx + dQ/dy = ",grind(dPdx_plus_dQdy)), 

  dx             : lratsubst(map("=",reverse(original_variables),reverse(varlist)),dx), /* we have to use reverse, because the transcendentals come at the end*/
  dy             : lratsubst(map("=",reverse(original_variables),reverse(varlist)),dy), /* and they depend on x,y so we substitute the transcendentals first  */
  dprint(3,"dx = ",dx), 
  dprint(3,"dy = ",dy), 


  /* ***** rational approach, not completely implemented yet ***** */
  if (searchRational=true) then (
    W : ratexpand(ratsimp(_x*_Q - _y*_P)),
    dprint(3,"W = ",W),
    dprint(3,"varlist = ",original_variables), 
    dprint(3,"P = ",_P), 
    dprint(3,"deg(P) = ",degree_l_t(_P,original_variables)), 
    dprint(3,"Q = ",_Q), 
    dprint(3,"deg(Q) = ",degree_l_t(_Q,original_variables)), 
    degree_ode : max(degree_l_t(_P,original_variables),degree_l_t(_Q,original_variables)),
    dprint(3,"degree of the ode = ",degree_ode),
    W_nplus1 : (_x*d_t(_Q,original_variables,degree_ode) - _y*d_t(_P,original_variables,degree_ode)),
    dprint(3,"W_nplus1 = ",W_nplus1),
    factorW : sublist(args(ratexpand(W_nplus1)),lambda([__x],not(integerp(__x)))),      
    dprint(3,"rational factors are : ",factorW)
    /* now construct all possible leading homogeneous terms of Darboux polynomials of degree k 
       and collect them in Sk */
    /* add lower-order terms */
  ),
  /* factorW contains the leading terms of the test polynomials. */
  /* we can remove from fList all polynomials with leading terms that are not in factorW */
  /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

  /* 1. declare dependencies x,y */
  depends(varlist,[_x,_y]),
  /* now define derivatives of new variables using gradef */
  for v in varlist do (
    apply('gradef,[v,_x,first(dx)]),
    apply('gradef,[v,_y,first(dy)]),
    dx:rest(dx),dy:rest(dy)
  ),


  /* replace dx and dy with the new variables */
  _P  : lratsubst(map("=",reverse(original_variables),reverse(varlist)),_P),  
  _Q  : lratsubst(map("=",reverse(original_variables),reverse(varlist)),_Q),  

  dx: diff(varlist,_x),
  dy: diff(varlist,_y),
  ddx : map(denom,dx), /* take the gradient of all variables wrt y and then take the denominator */
  ddy : map(denom,dy),
  denom_lcm : lcm([ddx,ddy]), /* compute the denominator of the least common multiple */
  dPdx_plus_dQdy : lratsubst(map("=",reverse(original_variables),reverse(varlist)),dPdx_plus_dQdy),

  dprint(3,"dx = ",dx), 
  dprint(3,"dy = ",dy), 
  dprint(3,"ddx = ",ddx), 
  dprint(3,"ddy = ",ddy), 
  dprint(3,"denom_lcm = ",denom_lcm),
  dprint(3,"dP/dx + dQ/dy = ",dPdx_plus_dQdy), 

 
  _P : _P * denom_lcm,
  _Q : _Q * denom_lcm,
  dPdx_plus_dQdy : dPdx_plus_dQdy * denom_lcm,
  _degree_ode : max(degree_l_t(_P,varlist),degree_l_t(_Q,varlist)),
  /* ******************************* */
  dprint(3,"P = ",_P), 
  dprint(3,"Q = ",_Q),
  dprint(3,"degree of the ode :", _degree_ode),

  /* note: if the degree of the ode is very large, the AIC degree can also be very large. therefore, it is maybe better to introduce new variables 
     X = x^highdegree, or maybe even several variables that represent the factors of x^highdegree */

  _k : degreeboundf, 
  method : false, /* no solution method was found yet */

  dprint(3,"************************"),
  dprint(3,"*** max degree = ", degreeboundf," *** "),
  dprint(3,"************************"),

  /* step 2: find all monic irreducible polynomials fi such that deg(fi) <= degreebound and fi divides D[fi] */
  [%Ci,fListofTerms] : PolyList(varlist,_k,%f), /* we have to reverse the varlist, so that the added term is always the leading term (note that varlist is [x1,x2,x3,x4,...,xn] and we have the ordering x1>x2>x3>x4>...>xn )*/

  /* fList contains a monomial basis (we need this for computation of the extactic and algebraic multiplicity) */
  dprint(3,"fList = ",fListofTerms),
  fListofTerms:rest(reverse(fListofTerms)), /* strip the constant (last element) because we don't want to start with that (or do we?)*/
  apply(declare,[''%Ci,constant]),
  dprint(3,"%Ci = ",%Ci),
  fi_backup : %Ci[1],   

  /* TODO: note that fList now contains the leading terms, in order. We can use that whenever we need the leading term of f */
  /* note that %Ci contains the leading coefficients, in order */

  /* 2. */
  fList:[],

  /* naively construct the test polynomial. */
  /* Maybe this is faster: first use all first order polynomials f1+x, f1+y, then the first order polynomials f1 + f2x + y, */   
   _i:1,
  for f in fListofTerms do (
    fi:fi_backup + f,
    fList:endcons(fi,fList),
    fi_backup : fi_backup + %Ci[_i+1]*f,         
    _i:_i+1
  ),

  /* fList now contains the complete polynomial*/
  dprint(3,"fList = ",fList),
  degree_f:1, 

  while length(fList)#0 and EXIT=false do (

    fi:first(fList), fList:rest(fList), /* we do it in this way because we can then add new fi to the list*/
    gi:0,
    degree_f : degree_l_t(fi,varlist), 
    dprint(3,"********************************"), 
    dprint(3,"fi = ",fi), 
    dprint(3,"degree(fi) = ",degree_f),
    dprint(3,"********************************"), 
    dprint(3,"P = ",_P),
    dprint(3,"Q = ",_Q),
    dprint(3,"x = ",_x),
    dprint(3,"y = ",_y),
    Dfi : ratexpand(_P*diff(fi,_x) + _Q*diff(fi,_y)),
    dprint(3,"Dfi = ",Dfi), 


    /* !!!!!!!!!!!!!!! */
    /* so how do we know when to do this substitution ????? */
    /* maybe: first switch back to original variables, simplify, then go back to internal variables */
    /* only do this if we have more than two variables in varlist */


    /* TODO: ratsimp is usually enough but is there a benefit in using radcan as well? */


    /* when is this beneficial? it makes 1.62,1.63 fail, but makes 1.112 run! */


    Dfi : ratsimp(lratsubst(map("=",varlist,original_variables),Dfi)),
     Dfi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Dfi),  


    dprint(3,"Dfi = ",Dfi), 

    /* !!!!!!!!!!!!!!! */
    dprint(3,"Dfi lexicographically ordered = ",lexicographicallyOrderedPolynomial(Dfi,varlist)),


    indivisible : false,
    feqns : [],

    while not(indivisible) and (Dfi#0) and (fi#0) do ( /* nijso added fi#0*/
      dprint(3,"fi = ",fi),
      dprint(3,"fi = ",grind(fi)),


      /* sometimes (when using non-rational approach) we get fractions and we need to divide fi by the gcd */
      /* TODO: when do we need to do this? It seems that this line is obsolete! If no further problems are */
      /* detected, lets delete it in january 2017 */
      /*fi : poly_primitive_part(fi,varlist),*/


      print("Dfi = ",Dfi),
      /* leading term of fi divides leading term of Dfi ? */
      lt_fi : l_t(fi,varlist),
      dprint(3,"lt_fi = ",lt_fi),

      dprint(3,"WE ARE GOING TO COMPUTE lt_DFI ",Dfi," ",varlist),
 
      lt_Dfi : l_t(Dfi,varlist), /* TODO: it seems that computing the leading term is computationally expensive: precompute? */        
      dprint(3,"lt_Dfi = ",lt_Dfi), 
      /* leading coefficients */
      lc_Dfi : l_c(lt_Dfi,varlist), /* leading coeff can be 2*a, 3.0*%e, etc.    */
      /*print("varlist = ",varlist),  */
      dprint(3,"lc_Dfi = ",lc_Dfi, "constant = ",constantp(lc_Dfi)), 
      counter: length(fi_in(lc_Dfi,%Ci)), 

      dprint(3,"*******************     F|DF ???               ***********************"),
      Dfi_fi : monomialdivide(lt_Dfi,lt_fi,varlist), /* divide lt(Dfi) by lt(fi) */

      dprint(3,"lt(Dfi)/lt(fi) = ",Dfi_fi),
      dprint(3,"number of fi's in Dfi_fi = ",counter),
      if Dfi_fi#false then (
        dprint(3,"lt(fi) divides lt(Dfi)"),
        /* lt(f) divides lt(Df) */
        gi : ratexpand(ratsimp(gi + Dfi_fi)),
        dprint(3,"gi = ",gi), 
        Dfi : ratexpand(ratsimp(Dfi - fi*Dfi_fi))
        ) 
      else if (constantp(lc_Dfi) and counter=0) then (dprint(3,"***** INDIVISIBLE *****"),indivisible:true)
      else if counter=1 then (
        dprint(3,"there is exactly one unknown coefficient in lc_Dfi"),
        _var:fi_in(lc_Dfi,%Ci)[1], /* get me the unknown coefficient */
        dprint(3,"vars in lc_Dfi = ",grind(_var)), 
        dprint(3,"lc_Dfi = ",grind(lc_Dfi)), 
        /* number of fi's in lc_Dfi = 1 */
        sList : solve(lc_Dfi,_var),
        dprint(3,"sList = ",sList),  /* sList might be a rational expression that can be simplified (already done below) */

        /* RATIONAL APPROACH : check if the solution is rational */


        sList : ratsimp(radcan(sList)), 

        dprint(3,"sList = ",sList),  /* sList might be a rational expression that can be simplified (already done below) */

        /* throw away all non-integers (rational approach!) */
        /*sList : sublist(map(lambda([__x],rhs(__x)),sList),integerp),   This command gives a list with only the right hand side */
        /* TODO: maybe better to use 'factor' instead of solve to fill sList? is it faster? */
        /* note: we do not yet want to throw away imaginary terms! */
  
        /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        /* not so fast! we first need to check if the content of the test polynomial is without fractions (we divide by the gcd of all coefficients)*/
        /* so at this point we need to split into numerator and denominator and multiply the test polynomial with the denominator */
        /* to get rid of fractions (we have poly_primitive_part command for this )*/ 
         

        /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        /*if freeof(%i,sList) then sList : sublist(sList,lambda([__x],integerp(rhs(__x)))),*/
        /*print("sList, keeping %i = ",sList),*/


        /* extra check for sqrt functions, should we check for more?*/
        /*
        if not(freeof(sqrt,dispform(sList,all))) then sList : sublist(sList,lambda([__x],integerp(rhs(__x)))),
        print("sList, throwing away sqrt = ",sList),
        */
          
    
        if sList # [] then (
          fiList    : makelist(fi,i,1,length(sList)), 
          feqnsList : makelist(feqns,i,1,length(sList)), /* equationslist */
          giList    : makelist(gi,i,1,length(sList)), 
          DfiList   : makelist(Dfi,i,1,length(sList)), 
          /* we could have more than one solution for var. We have loop over all solutions */
          dprint(3,"fiList = ",fiList), 
          dprint(3,"giList = ",giList), 
          dprint(3,"DfiList = ",DfiList), 
          /*fList : append(fiList,fList), *//* add the solutions to sList*/

          /* TODO: radcan is very slow. Do we really need this? there was a benefit using it in Dfi to simplify kamke1.39 */ 
          for s in sList do (
            Dfi   : first(DfiList),   Dfi   : ratexpand(ratsimp(radcan(subst(s,Dfi)))),            DfiList   : endcons(Dfi,rest(DfiList)),
            /* if Dfi=0 then all fi are solved, we can keep all fi in the list fi */ 

            fi    : first(fiList),    fi    : ratexpand(ratsimp(radcan(subst(s,fi)))),             fiList    : endcons(fi,rest(fiList)),
            feqns : first(feqnsList), feqns : ratexpand(ratsimp(radcan(subst(s,feqns)))),          feqnsList : endcons(feqns,rest(feqnsList)),
            gi    : first(giList),    gi    : ratexpand(ratsimp(radcan(subst(s,gi)))),             giList    : endcons(gi,rest(giList)),
            /* maybe the previous command reduced a term in feqn to zero (there was a term f1*f2 and we did a subst(f2=0))*/
            /* actually, if this happens, then it might be that other terms also simplify, but we can catch that with grobner */
         
            /* we should remove duplicates and zeros from feqns (NIJSO: can we also have this for fi,gi,Dfi?????)*/
            feqns:delete(0,feqns),  
            feqns:unique(feqns),
            dprint(3,"feqns = ",feqns)        
          ),
          fList : append(rest(reverse(fiList)),fList), /* we skip the last one and keep this value in fi*/ 

          /*print("fList = ",fList), */
          dprint(3,"fi = ",fi), 
          dprint(3,"Dfi = ",Dfi), 
          dprint(3,"gi = ",gi),
          if Dfi=0 and gi=0 then fi:0 /* Dfi,gi=0 happens when the variables in fi cancel, i.e. when varlist:[y,x,sqrt(x)] and fi:x - sqrt(x)^2 */ 
        ) else (
          indivisible : true /* there are no integer solutions */
        )
           
      ) else (
        /* we have more than 1 fi in lc_Dfi, we add it to feqns */
        dprint(3,"there are more than 1 unknowns in the leading coefficient"), 
        feqns : cons(lc_Dfi,feqns), /* add lc_Dfi to the list of feqns */
        dprint(3,"********************************"), 
        dprint(3,"feqns = ",feqns),
        dprint(3,"********************************"), 
        Dfi : expand(Dfi - lt_Dfi), /* nijso: ratexpand -> expand because it also simplifies expressions */
        dprint(3,"Dfi-lt_Dfi = ",grind(Dfi)) 
      )
    ), /* end while loop */


    /* ************************************************************************** */
    dprint(3,"Dfi = ",Dfi), /* this must be 0*/
    dprint(3,"feqns:",grind(feqns)), 
    if not(indivisible) and (length(feqns)#0) then (
      dprint(0,"Warning: we need to compute a groebner base (This is computationally expensive)!"),
      /* 1/2 compute groebner base */
      /* 2/2 if system is consistent then all unknown coefficients in fi and gi can be determined */
      /*     else jump the next step and try the next fi */
      _var : fi_in(feqns,%Ci),
      dprint(3,"unknown variables: ",_var), 
      feqns_grobner : poly_reduced_grobner(feqns,_var),
      dprint(3,"reduced grobner basis of feqns = ",feqns_grobner),
/*
      if (length(feqns_grobner)=1) then if (feqns_grobner[1]=1) then 
        print("inconsistent case!") 
      else (  
*/
      /* all coefficients can be computed */ 
      %rnum_list:[], 
      sList : algsys(feqns_grobner,_var),
      dprint(3,"sList = ",sList),
      for r in %rnum_list do sList:subst(0,r,sList), %rnum_list:[], /* replace all free variables with a value (here: 0)*/
      dprint(3,"sList = ",sList),
      /* we now have multiple solutions for fi. We now change fi and gi into a list. we first copy fi with the unknown coefficients*/

/*
          fiList : makelist(fi,i,1,length(sList)), 
          giList : makelist(gi,i,1,length(sList)), 
*/
      fiList : [],giList:[],

      dprint(3,"fiList = ",fiList),
      dprint(3,"giList = ",giList),
      for s in sList do (
        dprint(3,"s = ",s),
/*            fi:first(fiList), fi : subst(s,fi), fiList: endcons(fi,rest(fiList)),
            gi:first(giList), gi : subst(s,gi), giList: endcons(gi,rest(giList))
*/
        fiList : endcons(subst(s,fi),fiList),
        giList : endcons(subst(s,gi),giList)
      ),

      dprint(3,"fiList = ",fiList),
      dprint(3,"giList = ",giList),

      /* put the list in fi and gi*/
      fi : fiList,
      gi : giList
    ),

    dprint(3,"indivisible:",indivisible),
    if not(indivisible) then (
      /* make a copy of the old Sfg, because we have to check irreducibility excluding fi that are added in this loop */
      /*Sfg0 : Sfg, print("Sfg0 = ",Sfg0), */
      dprint(3,"fi = ",fi),
      dprint(3,"gi = ",gi),
      dprint(3,"fiList = ",fiList),
      dprint(3,"giList = ",giList),
      /* compute fi*conj(fi) to get a real fi, and compute D[f]/f to get the real cofactor*/
      /* note: if we find one complex fi, do we know which of the next equations will give us the complex conjugate? */
      /* if we do, we can skip this equation */
      dprint(3,"realSystem : ",realSystem),

      /* it is possible that f still has a free variable, e.g. kamke 1.118 (and that f|D[f] with this free variable), so we simply put this free variable to 0 */
      if not lfreeof(%Ci,fi) then (
        dprint(0,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"),
        dprint(0,"Invariant algebraic curve found with free variable!" ),
        dprint(0,"Extra free variables may be present in the solution!"),
        dprint(0,"Multiple solutions may be possible! Setting the variable to 0!"),
        dprint(0,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"),
        for _c in %Ci do fi:subst(0,_c,fi)
      ),

      /* make fi,gi into a list, */
      /* at this point we can also add all other solved fi that are in fiList */
      fi : flatten([fi]), 
      gi : flatten([gi]),
        
      tmpgiList : giList,  /* TODO: I don't like working with tmplists*/
      for f in fiList do (
        g : first(tmpgiList),tmpgiList:rest(tmpgiList),
        if lfreeof(%Ci,f) and freeof(f,fi) then (fi : endcons(f,fi),fiList:delete(f,fiList),gi:endcons(g,gi),giList:delete(g,giList))
      ),

/*
/* TODO: remove? */
         for g in giList do (
          if lfreeof(%Ci,g) and freeof(g,gi) then (gi : endcons(g,gi),giList:delete(g,giList))
         ),
*/  
 
      dprint(3,"fi = ",fi),
      dprint(3,"gi = ",gi),

 
      fiReal : [],
      giReal : [],
      for f in fi do (
        g : first(gi), gi:rest(gi),
        if (realSystem=true) and (convertImaginary=true) and not(freeof(%i,f)) then (
          dprint(1,"fi is complex, using fi*conj(fi) as Darboux polynomial instead : "),
          fReal : ratsimp(f*conjugate(f)),

              /* !!!!! at this location, we should check if fReal can be factored - if so, factor and compute the gReals*/
              /*sublist(list_of_factors(fReal),lambda([_x],not(integerp(_x)))),*/   /* throw away the multiplicities */

          gReal : ratsimp((_P*diff(fReal,_x) + _Q*diff(fReal,_y))/fReal),
          if freeof(%i,fReal) then (
            f : fReal,
            g : gReal
          ) else (
            dprint(0,"Warning: invariant algebraic curves were not simplified to real, keeping them complex!")
          )
        ),

        /* always recompute g */
        /*g : ratsimp((_P*diff(fReal,_x) + _Q*diff(fReal,_y))/fReal),*/


        fiReal : endcons(f,fiReal),
        dprint(3,"fiReal = ",f, fiReal),
        giReal : endcons(g,giReal),
        dprint(3,"giReal = ",g, giReal)

      ),  
      dprint(3,"fiReal = ",fiReal),
      dprint(3,"giReal = ",giReal),
      fi : fiReal,          
      gi : giReal,          
      dprint(3,"fi = ",fi),
      dprint(3,"gi = ",gi),




      /* at this point, check if the fi are trivial by converting back to normal variables and simplifying*/

      fi_originalVariables : lratsubst(map("=",varlist,original_variables),fi),
      fi_originalVariables : ratsimp(fi_originalVariables), 
      fi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),fi_originalVariables),

      /* also try to simplify the  cofactors (e.g. kamke1.112 needs this) */

      gi_originalVariables : lratsubst(map("=",varlist,original_variables),gi),
      gi_originalVariables : ratsimp(gi_originalVariables), 
      gi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),gi_originalVariables),




      dprint(3,"fi = ",fi),
      dprint(3,"gi = ",gi),

      for f in fi do (
        g : first(gi), gi : rest(gi),

        /* divide by the gcd of the coefficients to eliminate fractional coefficients */
        /* we can do this because D[c*f]/(c*f)  = c*D[f]/(c*f) = D[f]/f */
        f: poly_primitive_part(f,varlist),

        if lfreeof(varlist,f) then (
          dprint(3,"f is trivial : f=",f)
        )
        else if not(freeof(sqrt,dispform(f,all))) then (
          /* we keep the solutions with square roots, but we do not check for irreducibility */
          dprint(3,"f contains square roots, adding anyway : f=",f),
          Sfg : cons([f,g],Sfg) /* add [f,g] to the list of Darboux polynomials and cofactors */
        )
        else if irreducible(f,Sfg,varlist) then (
          dprint(3,"irreducible"),
          Sfg : cons([f,g],Sfg), /* add [f,g] to the list of Darboux polynomials and cofactors */
          dprint(3,"*** list of Darboux polynomials f and cofactors g: [[f1,g1],[f2,g2],...] = "),
          dprint(3,"Sfg = ",Sfg)
               
          /* TODO: it can happen that we find a reducible polynomial with factors that are not in Sfg, we then need to add all factors to Sfg! */
        ) else (
          dprint(3,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"),
          dprint(3,"!!!!!!!!!! not irreducible !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"),
          dprint(3,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        )
      )
    ),

    dprint(3,"wrapping up, preparing for the next f! "),

    /* if in the previous step we had an indivisible result or the result was irreducible, there is no need to go through the steps below because there was no new information added */
    if not(indivisible) and Sfg#[] then (

      /* get the cofactors g from Sfg and multiply with the variable ni, i=1..length(Sfg) */
      niList : makelist(concat(n,i),i,length(Sfg)),
      dprint(3,"niList = ",niList), 

      /* ********************************************************************************** */
      /* step 3, decide if there are constants ni, not all zero, such that sum(n_i*g_i) = 0 */
      /* ********************************************************************************** */
      dprint(1,"***** STEP 3 ***** "),
      Sum_nigi : apply("+",niList*map(rest,Sfg))[1],

      Sum_nigi_originalVariables : lratsubst(map("=",varlist,original_variables),Sum_nigi),
      Sfg_originalVariables : lratsubst(map("=",varlist,original_variables),Sfg),

      /* we need the transformed variables for this because we cannot have e.g. sin(x) as a variable*/
      Sum_nigi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sum_nigi_originalVariables),
      Sfg : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sfg_originalVariables),
      ni : ode1CheckDarboux(Sfg,varlist,niList,Sum_nigi),

      dprint(3,"sum_nigi = ",Sum_nigi),
      dprint(3,"Sfg = ",Sfg),
      dprint(3,"Vars = ",varlist),

      if ni # [] then ( 
        if length(delete(0,ni)) # 0 then (
          EXIT : true, 
          method: "firstIntegral",
          dprint(1," ***** FIRST INTEGRAL FOUND ***** "), 
          return(method)
        )
      ),

      /* ********************************************************************************** */
      /* step 4: step 3 failed, now we construct a nonzero right hand side -(dP/dx + dQ/dy) and add to Sum_nigi */
      /* note we assume that varlist[1] is the dependent variable and varlist[2] is the dependent variable, this is prone to error! */
      /* ********************************************************************************** */
      dprint(1,"***** STEP 4 ***** "),

      Sum_nigi : Sum_nigi - dPdx_plus_dQdy,
      dprint(3,"dPdx = ",dPdx_plus_dQdy),
      dprint(3,"sum_nigi = ",Sum_nigi),

      Sum_nigi_originalVariables : lratsubst(map("=",varlist,original_variables),Sum_nigi),
      Sfg_originalVariables : lratsubst(map("=",varlist,original_variables),Sfg),

      Sum_nigi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sum_nigi_originalVariables),
      Sfg : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sfg_originalVariables),
      ni : ode1CheckDarboux(Sfg,varlist,niList,Sum_nigi),

      dprint(3,"sum_nigi = ",Sum_nigi),
      dprint(3,"Sfg = ",Sfg),
      dprint(3,"Vars = ",varlist),

      if ni # [] then ( 
        EXIT : true, 
        method:"integratingFactor", 
        dprint(1," ***** INTEGRATING FACTOR FOUND ***** "), 
        return(method) 
      ),


      /* ********************************************************************************** */
      /* step 5: step 4 failed, now we try to find an exponential factor and determine the multiplicity */
      /* ********************************************************************************** */
      if (searchExponentialFactors = true) then (
        dprint(1,"***** STEP 5 ***** "),
        Sfg : delete([0,0],Sfg), /* delete darboux polynomials zero */

        /* note that we have as exponential factors exp(P/Q) and that Q can only be an invariant algebraic curve */
        /* when doe we need to search for exponential factors? only when we have already found Darboux polynomials, so length(Sfg)#0 ? */ 
        /* we can also construct Pdh/dx + Qdh/dy = h*k + f*k_g , with f and k the invariant algebraic curves and the cofactors*/
        /* note that Q = f1^m1 * f2^m2 * ... * fn^mn with fi the invariant algebraic curves */

        if Sfg#[] then (
          deg_Q : 1,
          deg_P : 1, /* note that the degree of P deg(P) is bound by deg(P)=deg(Q) + max(deg(M),deg(N)) */

          while (deg_Q <= degreeboundQ) do (
            dprint(3,"  *** exponential factor: deg(Q)=",deg_Q," / ",degreeboundQ),
            degreeboundP : min(deg_Q + max(degree_l_t(_P,varlist),degree_l_t(_Q,varlist)),degreeboundP),

            dprint(3,"degreeboundP = ",degreeboundP),
            while (deg_P <= degreeboundP) do ( 
              dprint(3,"  *** exponential factor: deg(P)= ",deg_P," / ",degreeboundP),
              mi: [],
              for i in integer_partitions(deg_Q,length(Sfg)) do (mi:append(mi,listify(permutations(i)))),
              dprint(3,"exponents mi = ",mi),
              /* >>>> loop from degree of P is 1 to maxdeg_P */
              /* construct polynomial for P */
              [%ai,pListofTerms] : PolyList(varlist,deg_P,%a),
              dprint(3,"coefficients of P : ",pListofTerms),  
              dprint(3,"%ai : ",%ai),  
              polyP :  apply("+",apply("*",[reverse(%ai),pListofTerms])),
              dprint(3,"polynomial P = ",grind(polyP)),
              /* construct eq. 13 */
              /* eq13 is given by: D[P] -P sum_i(mi* lambda_qi) = -prod_i(v_qi^mi)*(sum_j (c_j*lambda_sj + dy(M) + dx(N))) */

              for m in mi do (
                eq13:0,
                niList:[],

                for i:1 thru length(m) do (
                  ni : concat(n,i),
                  niList : endcons(ni,niList),
                  eq13 : eq13 + Sfg[i][2]*ni   
                ), 
                eq13 : eq13 - dPdx_plus_dQdy,

                polyQ : 1,
                for i:1 thru length(m) do (
                  polyQ : polyQ * Sfg[i][1]^m[i]  
                ),

                eq13 : eq13 * polyQ,
                /* D[P] = M*P_y + N*P_x */
                eq13b :  _Q*diff(polyP,_y) + _P*diff(polyP,_x), /* also note that we use x and y here! */
                eq13 : eq13 + eq13b,
                eq13c:0,

                for i:1 thru length(m) do (
                  eq13c : eq13c + m[i]*Sfg[i][2] 
                ),
                eq13 : ratexpand(eq13 - polyP * eq13c), 

                dprint(3,"eq13d = ",grind(eq13)),
                dprint(3,"varlist = ",grind(varlist)),

                niList : append(niList,%ai),
                /*apply(declare,[''niList,constant]),*/
                dprint(3,"niList = ",grind(niList)),
                _allcoef : allcoeffsNew(eq13,varlist),

                dprint(3,"all coefficients are : ",grind(_allcoef)),
                ni : flatten(errcatch(solve(_allcoef,niList))), /* we have to use errcatch because sometimes solve returns an error for certain trivial systems with free variables*/
                dprint(3,"ni = ",ni),
                if ni # [] then (
                  for r in %rnum_list do ni:subst(0,r,ni), %rnum_list:[], /* replace all free variables with a value*/
                  dprint(3,"exponential factor found!"),
                  polyP : subst(ni,polyP),
                  dprint(3,"P = ",grind(polyP)),
                  dprint(3,"Q = ",grind(polyQ)),
                  /* TODO: at this point, we can take the complex conjugate of p and q to make the exponential factor real */

/*
                  if realSystem=true and not(freeof(%i,[polyP,polyQ])) then (
                    polyPReal : ratsimp(polyP*conjugate(polyP)), 
                    polyQReal : ratsimp(polyQ*conjugate(polyQ)),
                    if (freeof(%i,[polyPReal,polyQReal])) and (freeof(conjugate,[polyPReal,polyQReal])) then (
                      polyP:polyPReal,
                      polyQ:polyQReal
                    ) else(
                      print("Warning: exponential factor was not simplified to real, keeping it complex!")
                    )
                  ),
*/
                  /*exponentialFactor : exp(ratsimp(polyP/polyQ)),*/ /* ratsimp is not necessary because polyP and polyQ are coprime! */
                  /* note that we are looking for a single exponential factor here!!! we can also have 2 or more exponential factors! */
                  /* even if we find an exponential factor, it does not mean that we can solve the equation */
                  /* we need at least a certain amount of exponential factors. How many? depends on degree, NrexponentialFactorsNeeded, NrCofactorsNeeded, */
 
                  exponentialFactor : endcons(exp(polyP/polyQ),exponentialFactor), 
                  /* the multiplicities of the Darboux polynomials fi are ni */ 
                  /* we have now exp(P/Q) * f1^n1 * f2n2 * f3^n3 * ... fp^np  */
                  ni : map(rhs,flatten(ni)), /* only give the right hand side */
                  dprint(3,"ni = ",ni),
                  EXIT : true, method:"Darboux", 
                  return(method) /* we now exit the mi-loop */
                )
              ), /* loop over mi */ 
              if (EXIT=true) then return(method),
              deg_P : deg_P + 1
            ), /* loop over P */
            if (EXIT=true) then return(method),
            deg_Q : deg_Q + 1
          ) /* loop over Q*/
        )  /* if Sfg#[] */
      ) /* end step 5 */
    ) /* end the loop over the trial polynomials with undetermined coefficients (the fi) */
  ), /* end the if statement for divisible */

  dprint(3,"*** end of iterations: list of Darboux polynomials f and cofactors g: [[f1,g1],[f2,g2],...] = "),
  dprint(3,"Sfg = ",Sfg),
  dprint(3,"ni = ",ni),
  Sfg : lratsubst(map("=",varlist,original_variables),Sfg), 
  dprint(3,"Sfg = ",Sfg),
  dprint(3,"Sfg = ",grind(Sfg)),
  /* substitute into Darboux polynomials and cofactors */
  if method#false then (

    ni : lratsubst(map("=",varlist,original_variables),ni), 
    exponentialFactor : lratsubst(map("=",varlist,original_variables),exponentialFactor), 
    /*denom_lcm : lratsubst(map("=",varlist,original_variables),denom_lcm),*/

    if not(freeof(%i,Sfg)) and (convertImaginary=true) then Sfg:radcan(exponentialize(Sfg)), /* try to simplify some imaginary numbers */

    dprint(3,"Sfg = ",grind(Sfg)),
    dprint(3,"ni = ",grind(ni))
    /*if sol#false then integratingFactor : lratsubst(map("=",varlist,original_variables),integratingFactor), */
/*
    integratingFactor:1,
    for figi in Sfg do (
      print("g = ",figi[1], ",   n = ",first(ni)),
      integratingFactor:integratingFactor*figi[1]^(first(ni)),
      ni:rest(ni) 
    ),
    integratingFactor : integratingFactor * exponentialFactor
*/
  ),

  dprint(3,"integrating factor = ",grind(integratingFactor)),
  dprint(3,"exponential factor = ",grind(exponentialFactor)),
  dprint(3,"max degree of Darboux polynomials = ",degree_f),
  if method="Darboux" then (
    dprint(1,"degree P,Q used = ",deg_P,deg_Q),
    exponentialFactor:lratsubst(map("=",varlist,original_variables),exponentialFactor),
    dprint(1,"exponential factor = ",exponentialFactor)
  ),

  remove(''%Ci,constant),
  remove(''constantlist,constant), /* remove constant declarations (note: should only remove when not already constant) */
  apply('kill,varlist),

  dprint(3,"end of prelle-singer method"), 
  return([method,Sfg,ni,exponentialFactor])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* returns an integrating factor given the Darboux polynomials with cofactors,*/
/* the multiplicities ni and the exponential factors                    ***** */
/* ************************************************************************** */
DarbouxIntegratingFactor(Sfg,ni,exponentialFactors):=block([integratingFactor,exponentialFactor],
  /* multiply all exponential factors in the list */
  exponentialFactor : apply("*",exponentialFactors),

  integratingFactor:1,
  for figi in Sfg do (
    dprint(3,"g = ",figi[1], ",   n = ",first(ni)),
    integratingFactor:integratingFactor*figi[1]^(first(ni)),
    ni:rest(ni) 
  ),
  integratingFactor : integratingFactor * exponentialFactor,

  return(integratingFactor)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* returns a list of all terms in the list Ci that occur in expr        ***** */
/* ************************************************************************** */
fi_in(_expr,_Ci):=block([_coeflist:[],_c],
  for _c in _Ci do (
    if not freeof(_c,_expr) then (
      _coeflist:cons(_c,_coeflist)
    )
  ),

  return(_coeflist)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* divide a multivariate monomial by another multivariate monomial      ***** */
/* if the denominator is free of the variables, then it could be divided***** */
/* ************************************************************************** */
monomialdivide(P,Q,_varlist):=block([_expr,_denom],
  _expr: P/Q,
  _denom : denom(_expr),
  if lfreeof(_varlist,_denom) then return(_expr) else return(false)
)$
/* ************************************************************************* */ 


/* ************************************************************************* */ 
/* check if the polynomial f is irreducible                            ***** */
/* Y.K. Man (1993): divide f by all elements in S.                     ***** */
/* If none of them divide f, then f is irreducible                     ***** */
/* note: S is a list of lists [[f1,g1],[f2,g2],[f3,g3]]                ***** */
/* ************************************************************************* */ 
irreducible(_f,_S,_varlist):=block([_Sf,_f_Sf,_irred:true],
  if length(_S)=0 then return(true),

  for _fg in _S do (
    _Sf:_fg[1], 
    dprint(3,"          *** _f = ",_f),
    dprint(3,"          *** Sf = ",_Sf),
    _f_Sf:poly_gcd(_f,_Sf,_varlist),
    dprint(3,"          *** _f_Sf = ",_f_Sf),

    if (_f_Sf#1) and (_f_Sf#-1) then _irred:false /* if it can be divided, then it is not irreducible*/
  ),

return(_irred)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* construct a multivariate polynomial of degree _degree with undetermined    */
/* coefficients _coeffs in the variables contained in varlist, note that      */
/* varlist is used for lexicographic ordering and we want to keep the ordering*/
/* ************************************************************************** */
PolyList(_varlist,_degree,_coeffs) :=block([_somavar,_L,_C,_Pterms,_ai,_xx],
  _somavar:1+apply("+",_varlist),
  _L:args(ratexpand(_somavar^_degree*2)),         /* multiply by 2 so every term has constant coefficient */

  /* we have the polynomial C1*P1(x,y) + C2*P2(x,y) + C3*P3(x,y), etc for varlist [x,y] */
  _C:map(first,map(args,_L*_xx)),                 /* get all constant coefficients */
  _Pterms:apply("/",[_L,_C]),                          /* strip constants from polyterms by dividing by C*/

  _ai:makelist(concat(_coeffs,_i),_i,length(_Pterms)), /* undetermined coefficients */
  _Pterms : apply("+",_Pterms),                         /* change from list to polynomial */
  _Pterms : lexicographicallyOrderedPolynomial(_Pterms,_varlist),

  return([_ai,_Pterms])                                /* P is a list of polynomial terms*/
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* compute the relative complement of La in Lb,                               */
/* so compute a list with all members in Lb that are not in La                */
/* ************************************************************************** */
complement(_La,_Lb):=block([_i],
  for _i in _La do 
    _Lb:delete(_i,_Lb),
  return(_Lb)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* creates basis of functions for which we take the multivariate polynomials  */ 
/* ************************************************************************** */ 
BasisFunctions(_M,_N,_y,_x):=block([_LBasisFunctions,_TrimmedList:[],_a,sol1,previousEntries,nextEntries,currentEntry,goodEntry],
  dprint(3,"computing basis functions"), 

  _LBasisFunctions:showratvars([_N,_M]), /* list of all unknowns */
  /* now add to the list the derivatives wrt the dependent and independent variable */
  /* nijso: actually, we have to do this again to make sure that derivatives of derivatives are now in the list... we dont do this!*/ 
  _LBasisFunctions:append(map(lambda([_a],diff(_a,_x)),_LBasisFunctions), map(lambda([_a],diff(_a,_y)),_LBasisFunctions), _LBasisFunctions), 
  _LBasisFunctions:showratvars(_LBasisFunctions), 


  /* remove everything that is not depending on x,y */
  for _a in _LBasisFunctions do 
    if not freeof(_x,_y,_a) or diff(_a,_x)#0 or diff(_a,_y)#0 then 
      _TrimmedList:cons(_a,_TrimmedList), 
  /* */ 
  /* This section comes to insure proper substitution (no internal substitutions)*/ 
  /* inside the transcendentals ! */ 
  _LBasisFunctions:[], 

  /* check for double entries  (we need to keep the correct order) */
  while _TrimmedList # [] do( 
    _a:first(_TrimmedList), 
    _TrimmedList:rest(_TrimmedList),
    if not(member(_a,_LBasisFunctions)) then 
      _LBasisFunctions:endcons(_a,_LBasisFunctions) 
  ),

  _TrimmedList:_LBasisFunctions, 

  /* nijso added to make sure that y,x are always the first 2 variables */
  _TrimmedList : delete(_y,_TrimmedList),
  _TrimmedList : delete(_x,_TrimmedList),
  _TrimmedList : cons(_x,_TrimmedList),
  _TrimmedList : cons(_y,_TrimmedList),

 
  /* if a basis function f1 depends on another basis function f2, then place f1 after f2, such that
   the list of basisfunctions is sorted such that fi depends only on f1,...,fi-1. This is important 
   for the substitution of the basis functions */
  if length(_TrimmedList) > 3 then (
    _TrimmedList : rest(_TrimmedList,2), /* list without x and y */
    dprint(3,"length of list larger than 3, trying to reorder ",_TrimmedList),
    /* we have to reorder in such a way that entry k does not depend on entries that come after k */

    previousEntries : [],
    nextEntries : _TrimmedList,

    while nextEntries # [] do (
      currentEntry : first(nextEntries),
      nextEntries : rest(nextEntries),
      goodEntry : true,
      for _i in nextEntries do (
        if not freeof(_i,currentEntry) then (
          goodEntry : false,
          nextEntries : endcons(currentEntry,nextEntries)
        )
      ),
      if goodEntry=true then previousEntries : endcons(currentEntry,previousEntries)
    ), 

    _TrimmedList : previousEntries,
    _TrimmedList : cons(_x,_TrimmedList),
    _TrimmedList : cons(_y,_TrimmedList),

    dprint(3,"finished reordering")
  ),

  return(_TrimmedList)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* check if pde is a first order PDE,   transform to system of 1st order odes */
/* ************************************************************************** */
PDE1toODE1(pde,U,indepvars):=block([z,s],

  dprint(3,"PDE = ",pde),

  if freeof('diff,pde) then (dprint(0,"Error: no differential operator (diff) found!"), return(false)),

  for x in indepvars do 
    if derivdegree(pde,U,x) # 1 then (dprint(0,"Error: no first order PDE found!"), return (false)), 


  if not freeof("=",pde) then pde : lhs(pde) - rhs(pde),

  /* ?check if U is the only dependent variable */
  /* ... */
  /*                                                */

  /* ? check if there are other independent variables */
  /* ... */
  /*                                                  */


  /* the PDE is of first order. Now get all the coefficients. First substitute local variables dU/dx = dx1, dU/dy=dx2, etc */
  j:1,
  odeSystem:[],

  /* compute the characteristic strip */
  for i in [x,y,z] do (
    dprint(3,"pde=",pde),
    terms:bothcoeff(pde,'diff(U,i)),
    odeSystem:endcons('diff(i,s)=terms[1],odeSystem),
    pde:ratsimp(terms[2]),
    dprint(3,"ode system = ",odeSystem),
    dprint(3,"pde=",pde),
    j:j+1
  ),
  odeSystem:endcons('diff(%s,s)=pde,odeSystem),



  /* method of characteristic equations: each of the independent variables introduces a first order ODE */
  /* we need to find the coefficients of the differential operators belonging to the independent variables */

  /* so each term a(x1,x2,...,xn) * diff(U,xi)  leads to an ode diff(xi,s) = a(x1,x2,...,xn)  */

  return(true)
)$
/* ************************************************************************** */




/* ************************************************************************** */
/* solve a first order PDE                                                    */
/* ************************************************************************** */ 
PDE1Solve(pde,U,indepvars,[boundaryconditions]):=block([],

  /* step 0: check input (is an equation, is a PDE, is first order, is linear/quasilinear/semilinear/nonlinear)*/ 

  /* step 1: rewrite to first order system (method of characteristics) */
 
  /* step 2: solve, first solve the decoupled equations, then substitute and try to decouple the other equations */
  /*         using grobner basis might also help here */

  return(true)
)$
/* ************************************************************************** */



/* ************************************************************************** */
/* check ode input and rewrite right-hand side                                */
/* ************************************************************************** */ 
checkPSInput(_ode,_y,_x,ODEtype):=block([_rhs,_df,_df_x,_df_y,_P,_Q],

  if freeof('diff,_ode) then (dprint(0,"Error: no differential operator (diff) found!"), return(false)),
  if derivdegree(_ode,_y,_x) # 1 then (dprint(0,"Error: No first order ODE found!"), return (false)), 

  dprint(3,"ode = ",_ode), 
  dprint(3,"y,x = ",_y,_x), 

  /* try to solve explicitly in the derivative */
  _ode:solve(_ode,'diff(_y,_x)),
 
  if not listp(_ode) then (dprint(0,"Error: could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(false)),
  if length(_ode) > 1 then dprint(0,"Warning: writing the ODE in the explicit form dy/dx=f(x,y) leads to multiple ODEs (only solving the first!): ",_ode),

  _ode : _ode[1],
  if lhs(_ode)#('diff(_y,_x)) then (dprint(0,"Error: could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(false)),
 
  _rhs : rhs(_ode),


  if (convertTrig=false) then  
  _rhs:ratsimp(trigexpand(trigsimp(rhs(_ode)))),   /* trigsimp writes sec(x) as 1/cos(x) and tan(2*x) as sin(2*x)/cos(2*x), and trigexpand writes sin(2*x) as 2*sin(x)*cos(x), this will solve kamke1.81  */
                                                   /* note that in general, we want a true transcendence base, so convertTrig=true and there should not be any sin,cos left here */   

  /* we have to check if the ode contains general functions */
  dprint(3,"gradefs = ",gradefs),

  if (heuristics=false) then (
    varlist : showratvars(_rhs), /* all free variables */
    /*varlist : sublist(varlist,lambda([_i],lfreeof(gradefs,_i))),*/ /* remove variables that have gradients defined (we define gradefs when convertTrig=true) */ 
    varlist : sublist(varlist,lambda([_i],not(lfreeof(map(op,dependencies),_i)) or not(lfreeof(dependencies,_i)) or not(freeof('diff,diff(_i,_y))) or not(freeof('diff,diff(_i,_x))))),
    if varlist # [] then (
      dprint(0,"Error: Prelle-Singer method cannot handle general functions."),
      dprint(0,"try again with option 'heuristics=true"),
      return(false)
    )
  ),

  dprint(3,"rhs = ",_rhs),
 
  /* splits square roots sqrt(a*b) into sqrt(a)*sqrt(b) and sqrt(a/b) into sqrt(a)/sqrt(b) */
  _rhs : rootsexpand(_rhs),
  _Q : num(_rhs),
  _P : denom(_rhs),
  dprint(3,"P = ",_P),
  dprint(3,"Q = ",_Q),

  /* The P-S assumes the variables y,x to be independent */
  /* so we remove the possible dependency                */ 
  /* we have y(x) or x(y) and we want y,x */
/*
  if (radcan(diff(_y,_x)) # 0) or (radcan(diff(_x,_y))#0) then (
    print("removing x-y dependency"),
    Y_X_DEPEND:true, 
    _ode:subst(%x%,_x,subst(%y%,_y,_ode)), 
    LISTOFTERMS:subst(%x%,_x,subst(%y%,_y,LISTOFTERMS)),

    /* Pick all atoms for which gradient with respect to x,y was defined */ 
    /* so if we have f, then we can define df=diff(f,x) to deal with these functions */
    if ODEFI_GRAD_LIST # nil then (
      ODEFI_GRAD_LIST:subst(%x%,_x,subst(%y%,_y,ODEFI_GRAD_LIST)), 
      for _dfs in ODEFI_GRAD_LIST do (
        _df:lhs(_dfs),
        _df_x:diff(_df,_x),
        _df_y:diff(_df,_y), 
        if _df_x#0 or _df_y#0 then (
          apply('gradef,[_df,%x%,subst(%x%,_x,subst(%y%,_y,_df_x))]), 
          apply('gradef,[_df,%y%,subst(%x%,_x,subst(%y%,_y,_df_y))]) 
        ) 
      )
    )
  ) 
  else (%y%:_y,%x%:_x),
*/
  dprint(3,"ODE:",_ode),
  dprint(3,"x (independent variable) : ",_x),
  dprint(3,"y (dependent variable) : ",_y),

  /* dy/dx = M/N =Q/P*/ 
  /*_P:  ratcoeff(_ode,'diff(_y,_x),1),   */
  /*_Q: -ratsimp(_ode - _P*'diff(_y,_x)), */

  /* we have to make sure that P and Q do not contain fractions, because then grobner will multiply the input polynomials with all denominators */
  dprint(3,"P = ",_P),
  dprint(3,"Q = ",_Q),

  /* dy/dx = M/N = Q/P */
  return([_ode,_y,_x,[_P,_Q]])
)$
/* ************************************************************************** */


/* this stuff below is for simplifying constants of integration appearing in exponentials, like exp(%c+a*x) */
/* this can be simplified to %c*exp(a*x) */
matchdeclare (_a, lambda ([_e], _e#0 and freeof(_x, _e)), _b, freeof(_x));
defmatch (linearp, _a*_x + _b, _x);

/* detect p1*sqrt(p2/q2) and split into sqrt(p2) and sqrt(q2) */
matchdeclare(_p1,lambda([_e1],_e1#0),_p2,lambda([_e3],_e3#0),_q2,lambda([_e4],_e4#1));
defmatch(sqrtOfFraction,_p1*sqrt(_p2/_q2));



/* ************************************************************************** */
/* splits and expression containing square roots and factorizes the           */
/* square roots such that                                                     */
/*   sqrt((p1*p2*...pn)/(q1*q2*..qm))                                         */
/*   = sqrt(p1)*sqrt(p2)*...sqrt(pn)/(sqrt(q1)*sqrt(q2)*..sqrt(qm))           */
/* this is the inverse of rootsexpand                                         */
/* ************************************************************************** */
rootsexpand(expr) :=block([splitExpr:expr],
  if not(freeof(sqrt,dispform(expr,all))) then (
    dprint(3,"trying to split square root terms"),
    /* get a list with all the sqrt terms */
    sqrtList:sublist(showratvars(expr),lambda([_x],not(freeof(sqrt,dispform(_x,all))))),
    insideSqrtList : flatten(map(args,sqrtList)), 
    factorsInsideSqrtList:map(factor_list,insideSqrtList), 
    factorsInsideSqrtList:map(sqrt,factorsInsideSqrtList),

    splitSqrtList:[],
    for _L in factorsInsideSqrtList do (  
     _X : 1,
     for _i in _L do _X:_X*_i,
     splitSqrtList : endcons(first(sqrtList) = _X,splitSqrtList),   
     sqrtList : rest(sqrtList)
    ),
    splitExpr : subst(splitSqrtList,expr)
  ), 

  return(ratsimp(splitExpr))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* returns factors as lists (Stavros Macrakis) */
/* ************************************************************************** */
factor_list(ex):=
  if mapatom(ex) then [ex] else            /* don't factor numbers */
    block([fex: factor(ex),inflag:true],
          if mapatom(fex) or op(fex)#"*" then [fex]
	  else args(fex)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* partitioning (Richard Fateman)                                             */
/* ************************************************************************** */
partition_expression(operator,pred,init,combiner,action,res,E):= block(
[yes:init,no:init],
  if not atom(E) and inpart(E,0)=operator then (
    map(lambda([r], if apply(pred,[r])=false
    then  
      no:apply(combiner,[r,no])
    else 
      yes:apply(combiner,[r,yes])),
    inargs(E) ),
    res :: apply(action, [yes,no]), /* result stored as requested */
  true)
)$
/* ************************************************************************** */

/* ************************************************************************** */
inargs(z):=substinpart("[",z,0)$
/* ************************************************************************** */


/* ************************************************************************** */
/* we have a solution to the ODE,                                             */
/* simplify it and also try to create a clean integration constant            */
/* ************************************************************************** */
cleanupODESolution(expr,_y,_x):=block([res1:[],expr1,realexpr:false,expressionBecameComplex:false,logmin1:false,linearconstants,_A,_B,_X],
  /*dprint(3,"clean up ",grind(expr)),*/
  /* first, evaluate all unevaluated noun forms */
  expr: ev(expr,nouns),
  dprint(3,expr),
  
  if freeof(%i,expr) then realexpr:true,
  /*dprint(3,"is expression real: ",realexpr),*/

  expr : ratsimp(trigreduce(trigsimp(expr))),
  /*dprint(3,"1: ",expr),*/

  /* simplify some logarithms */
  if not(freeof(log,expr)) then (
    expr1:logcontract(radcan(expr)), 
    if (realexpr=true) and not(freeof(%i,expr1)) then expressionBecameComplex:true,
    if not(freeof(log(-1),expr1)) then logmin1:true,
    if expressionBecameComplex=false and logmin1=false then expr:expr1
  ),
  /*dprint(3,"2: ",expr),*/

  /* simplify some complex expressions */
  if not(freeof(%i,expr)) and (convertImaginary=true) then expr: rectform(expr), /* to convert for instance (-1)^%i */
  /*dprint(3,"3: ",expr),*/

  if not freeof(_y,expr) then (
    /* then, try to solve explicitly in terms of the dependent variable. If the solution contains integrals, */
    if not freeof(integrate,expr) then (
      declare(integrate,linear),
      expr1:solve(expr,_y),
      remove(integrate,linear)
    )
    else expr1:solve(expr,_y),

    if (realexpr=true) and freeof(%i,expr1) then ( 
      if expr1 # [] and freeof(_y,rhs(expr1)) then expr:expr1 else expr:[expr=0]
    )

  ),
  /*dprint(3,"4 : ",expr,_y,_x),*/

  if(lhs(expr[1])=_y) then (
    linearconstants:linearp(ratexpand(rhs(expr[1])),%c),
    if linearconstants#false then (
     _A:rhs(linearconstants[1]),
     _B:rhs(linearconstants[2]),
     _X:rhs(linearconstants[3]),
     dprint(3,_A,", ",_B,", ",_X),
     if not atom(_B) and (op(_B)="-") then _B: - _B, /* if we have y=f(x) -B(x)*%c then change to y=f(x)+B(x)*%c */
     if (_B#0) and (freeof(_x,_B)) then _B:1,        /* if we have y=f(x) +B*%c with B a constant, change to y=f(x) + %c */ 
     expr: [_y = _A + _B*_X ]
    )  
  ),
  /* for some reason we need to do ev,nouns  again */ 
  /*dprint(3,"6 : ",expr),*/
  expr:ev(expr,nouns),
  expr:SimpConstInExp(expr,_y,_x),
  /*res:MakeConstPos(res),*/

  return(expr)
)$
/* ************************************************************************** */
 

/* ************************************************************************** */
/* simplify constant appearing in exponential term                            */
/* we could have y= f(x) + exp(%c)                                            */
/* ************************************************************************** */ 
SimpConstInExp(expr,depvar,indepvar):=block([_Expterms,_coef:0,_newExpr,_subst],
  /* temporary substitution */
  subst(%c%,%c,expr),

  _newExpr:expr,
  _Expterms: allTerms(expr),

  if length(_Expterms)>0 then  
    for i:1 thru length(_Expterms) do   
      if not(freeof(depvar,_Expterms[i][1])) or not(freeof(indepvar,_Expterms[i][1])) then _subst:false,

  if length(_Expterms)>1 then   
    for i:2 thru length(_Expterms) do   
      if _Expterms[i-1][1]#_Expterms[i][1] then _subst:false,

  if _subst=false then return(expr),

  for arg in _Expterms do 
    _newExpr:subst(%c*exp(arg[2]),exp(arg[1]*%c+arg[2]),_newExpr),

  /* this happens when there were other %c terms in the expression that are not inside exp(), like %c*exp(a*%c+b) */
  if not freeof(%c%,_newExpr) then return(expr),

  return(_newExpr)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ************************************************************************** */
MakeConstPos(expr):=block([newexpr],
  newexpr: ratsimp((ratexpand(rhs(expr)-lhs(expr)+%c))),
  if freeof(%c,newexpr) then return(ratsimp(expr+2*%c))
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* collect all terms exp(a(x,y)*%c+b(x,y)) */
/* ************************************************************************** */
allTerms(expression):= block( [ ],
  allOpsPriv (expression,[])
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* ************************************************************************** */
allOpsPriv(expression, opList) := block ( [_x, _args, _constcoef,
  _expterm,_newList:opList,_lp],

  if atom(expression) then opList else (
    _x: op(expression),
    _args: args(expression),
    if (_args[1] = %e)  and not freeof(%c,_args[2]) then (
      /* only exponential terms containing %c */
      _lp : linearp(_args[2],%c),
      if _lp=false then return(opList), /* capture in case linearp is false */ 
      _constcoef:rhs(_lp[2]),
      _expterm:rhs(_lp[1]),
      /*if freeof(constcoef,depvar) and freeof(constcoef,indepvar) then*/
      _newList: cons([_constcoef,_expterm],opList)
    ),
    for arg in _args do
      _newList: allOpsPriv(arg, _newList),
    _newList
  )

)$
/* ************************************************************************** */


/* ************************************************************************** */
/* specialintfactor: Procedure finding integrating                            */
/* factor belonging to some of the classes discussed                          */
/* in the book by Davis. Introduction to non linear                           */
/* differential and integral equations.                                       */
/* Dover Pub. 1962                                                            */
/*                                                                            */
/* we should test here if the equation is :                                   */
/* 0. simple symmetries of the form y'=f(x) (linear) and y' = f(y) (separable)*/
/* 1. linear */
/* 2. exact  */
/* 3. separable */
/* ************************************************************************** */
specialintfactor(_M,_N,_y,_x):= 
  /* input : p,q are such that the equation is p*dx+q*dy=0 */ 
  /* output: f, the integrating factor */ 
  /* INTFACTOR_FI is set to f, METHOD_FI describes the method used */ 
  /* */ 
block([MU,_rhs,_xi,_eta,linearconstants],
  /* dy/dx = M/N   ==>   Mdx = Ndy      Mdx - Ndy = 0*/ 
  _rhs:ratsimp(_M/_N), 

  /* check if RHS is of the form f(x) + g(x)*y */
  linearconstants:linearp(ratexpand(_rhs),_y),
  dprint(3,"rhs = ",_rhs, " ",_y),
  dprint(3,"linearconstants = ",linearconstants),


  /* ----- y' = f(y) ----- */
  if freeof(_x,_rhs) then (
     dprint(3,"y' = F(y)"),  
     method: "F(y)",
     _xi:1,
     _eta:0
  ) 
  else 
  /* ----- y' = f(x) ----- */
  if freeof(_y,_rhs) then (
     dprint(3,"y' = F(x)"),  
     method: "F(x)",
     _xi:0,
     _eta:1
  ) else 
  if linearconstants # false then (
    _f: rhs(linearconstants[1]), 
    _g: rhs(linearconstants[2]), 

    /* ----- y' = f(x)*y ----- */
    if _f=0 then (
     dprint(3,"y' = g(x)*y"),  
     method: "g(x)*y",
     _xi:0,
     _eta:_y 
    ) else ( 
    /* ----- y' = f(x) + g(x)*y (general linear ode) ----- */
     dprint(3,"y' = f(x)+g(x)*y"),  
     method: "f(x)+g(x)*y",
      /* symmetry generators for linear eq */
      _xi : 0,
      _eta: exp(integrate(_g,_x))
    )
  ) else
  /* ----- EXACT ODE ----- */
  if (ratsimp(diff(_N,_x)+diff(_M,_y))=0) then (
    dprint(3,"equation is exact"),
    /*INTFACTOR_FI:1,*/
    method:"exact",
    _xi:1/_M, _eta:0
  ),

 if method # false then (
   MU:ratsimp(1/(_xi*_M-_eta*_N)), /* this is the integrating factor*/
   dprint(3,"_xi = ",_xi,", M =  ",_M,", _eta =  ",eta,", N =  ",_N),
   return([method,MU])
 ),

  return([false,false])
)$ 
/* ************************************************************************** */


/* ************************************************************************** */
/* get the degree term of the polynomial (all terms with degree n)            */
/* ************************************************************************** */ 
d_t(_expr,_varlist,_n):=block([PList,DList,localdegree],
  if atom(_expr) and (_n=0) then return(_expr),
  if atom(_expr) and (_n#0) then return(0), 
 
  PList:args(ratexpand(_expr)),

  DList : [],
  for P in PList do (
    localDegree:0,
    for v in _varlist do (   
      localDegree : localDegree + hipow(P,v)
    ),
    if localDegree=_n then DList : endcons(P,DList)  
  ),

  return(apply("+",DList))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ************************************************************************** */
/*
ode1_singularpoints(ode,y,x) :=block([],
  /* check the expression and split it into a numerater and a denominator */
  _check: checkPSInput(expr,_y,_x,'firstorder),
  if _check # false then 
    [res,_y,_x,[_P,_Q]] : _check
  else return(false),
  
  /* so we have a multivariate polynomial P, how do we compute its zeroes? with groebner? */
  Pzeroes : to_poly_solve(P,[vars],'use_grobner=true),

)$
*/
/* ************************************************************************** */


/* ************************************************************************** */
/* ----- simple method of finding the constant factor in front of an equation */
/* step 1: construct a set of args(expr)                                      */
/* step 2: determine the subset containing only constants                     */
/* ************************************************************************** */
constant_factors(_expr,_varlist) := block([inflag:true,_constantfactors:1,_oldratvars],

  if not(listp(_varlist)) then _varlist : [_varlist],

  _oldratvars : ratvars, 
  ratvars : _varlist, /* this was done globally elsewhere, should we do it only locally? */
  _expr : ratsimp(_expr),

  if lfreeof(_varlist,_expr) then 
    _constantfactors:_expr
  else if not mapatom(_expr) and op(_expr)="*"
  /* we know that the internal dependent variable is _x,and we want expr to be free of x */
  /* constantp doesn't knowthat abs(a) is constant */
  then 
    _constantfactors : xreduce("*",listify(subset(setify(args(_expr)),lambda([_u],lfreeof(_varlist,_u))))),

  ratvars : _oldratvars,

  return(_constantfactors)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* returns a list of all coefficients of the polynomial _expr(_varlist)       */
/* ************************************************************************** */
allcoeffsNew(_expr,_varlist):=block([_sign:1,_lt,coeflist:[]],
  _expr : lexicographicallyOrderedPolynomial(ratexpand(_expr),_varlist),

  for p in _expr do (
   coeflist : endcons(constant_factors(p,_varlist),coeflist)
  ),

  return(coeflist)
)$
/* ************************************************************************** */


/* ************************************************************************** */ 
/* compute lexicographic value of a monomial based on the ordering in varlist */
/* the lexicographic value is computed as follows:                            */ 
/* if B=length(varlist) then we use numbering in base B                       */
/* and we compute a decimal value                                             */
/* for instance if varlist:[x,y,z] then we use base 3,                        */
/* where z=0,y,1,x=2, (also: zz=0,zy=1,zx=2) yz=3,yy=4,yx=5, etc              */
/* ************************************************************************** */
lexval(_expr,_varlist):=block([bit:0,count:1,var,P,value:0,Base],
  Base : length(_varlist), 
  for var in reverse(_varlist) do (
    P:hipow(_expr,var), 
    if P#0 then value: value + sum(count*Base^j,j,bit,bit+(P-1)), 
    count:count+1,
    bit:bit+P
  ),

  return(value)
)$
/* ************************************************************************** */

/* ************************************************************************** */ 
/* order a polynomial based on lexicographic order of the terms in varlist.   */ 
/* varlist=[x,y,z,...], x>y>z>...                                             */
/* ************************************************************************** */ 
lexicographicallyOrderedPolynomial(_expr,_varlist):=block([_argsList,_valList:[],_counter:1,_sL,_sortedList:[],_currentNr:-1,_NR:0],


dprint(3,"expression = ",grind(_expr)),


  /* first, order based on degree and put terms of equal degree in a sublist */
  if atom(_expr) or op(_expr)#"+" then 
    return([_expr]) 
  else 
    _argsList:args(expand(_expr)),
/*    _argsList:args(expandwrt(_expr,_varlist)),*/

  for i in _argsList do (
    _valList:endcons([lexval(i,_varlist),_counter],_valList),
    _counter:_counter+1
  ),

  _sL : sort(_valList,lambda([_a,_b],_a[1]>_b[1])),

  for i in _sL do (
     _NR:i[1], 
     if(_NR # _currentNr) then (
        _sortedList:endcons(_argsList[i[2]],_sortedList)
     ) 
     else (
        _sortedList[length(_sortedList)]:_sortedList[length(_sortedList)]+_argsList[i[2]]
     ),

     _currentNr:_NR 
  ),

  return(ratsimp(_sortedList))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* order a polynomial based on lexicographic order of the terms in varlist.   */ 
/*   varlist=[x,y,z,...], x>y>z>...                                           */
/* ************************************************************************** */
oldlexicographicallyOrderedPolynomial(_expr,_varlist):=block([_lexList,_index,_mergedLexList,_current],

  /* first, order based on degree and put terms of equal degree in a sublist */
  if atom(_expr) or op(_expr)#"+" then 
    return([_expr]) 
  else 
    _lexList: (sort(args(ratexpand(_expr)),lambda([z1,z2],is(lexval(z1,_varlist)>lexval(z2,_varlist))))),

  /* merge entries with the same lexvalue */
  _index : 1,
  _mergedLexList : [first(_lexList)],
  _lexList : rest(_lexList),  
  while _lexList#[] do (
    _current : first(_lexList), 
    if lexval(_current,_varlist)=lexval(_mergedLexList[_index],_varlist) then (
      _mergedLexList[_index] : ratsimp(_mergedLexList[_index] + _current) 
    ) 
    else (
      _index : _index+1,
      _mergedLexList : endcons(_current,_mergedLexList) 
    ),
    _lexList : rest(_lexList)  
  ),

  return(_mergedLexList)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* compute leading term of a polynomial using total degree ordering in varlist*/ 
/* note that var : [x1,x2,x3,...,xn] and x1 > x2 > x3 > .. > xn               */
/* ************************************************************************** */
l_t(_expr,_varlist) :=block([_lt,_deg_lt,_loc_order,_terms,_deg_x,_order],
  _expr : ratexpand(_expr),

  /* NB: use ratsimp to write a*x + b*x as (a+b)*x */
  return(ratsimp(lexicographicallyOrderedPolynomial(_expr,_varlist)[1]))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* get the leading coefficient of the polynomial using lexicographic ordering */ 
/* in varlist                                                                 */   
/* ************************************************************************** */
l_c(_expr,_varlist):=block([],
  _expr : ratexpand(_expr), /* constant_factors can deal with a*x+b*x*/

  return(constant_factors(l_t(_expr,_varlist),_varlist))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* compute degree of leading term using lexicographic ordering                */
/* note that var : [x1,x2,x3,...,xn] and x1 > x2 > x3 > .. > xn               */
/* ************************************************************************** */
degree_l_t(_expr,_varlist) :=block([_lt,_deg_lt],

  _expr : ratexpand(_expr),
  _lt : l_t(_expr,_varlist),

  _deg_lt : 0,
  for var in _varlist do 
    _deg_lt : _deg_lt + hipow(_lt,var),

  return(_deg_lt)
)$
/* ************************************************************************** */





/* ************************************************************************** */
/* compute the nth extactic curve (algebraic multiplicity) */
/* X is the vector field */

/* Some theory:  
1. Every algebraic curve of degree n invariant by the vector field X is a factor of Extactic(X,n)
2. an invariant algebraic curve f of degree n for the vector field X has multiplicity
   k when k is the greatest positive integer such that the kth power of f divides Extactic(X,n)
*/
/* assumes variables x,y */
/* ************************************************************************** */
Ecstatic(_P,_Q,_varlist,_n):=block([_l],
  _l : (_n+1)*(_n+2)/2,
  dprint(3,"l = ",_l),
  _X(_v):= _P*diff(_v,x) + _Q*diff(_v,y),

  /* first, compute a basis of polynomials in C[x,y] of degree at most n*/
  /* at first instance, only use x,y*/

  _Xnew : reverse(PolyList(_varlist,_n,%f)[2]),
   dprint(3,"polynomial basis = ",_Xnew),


  _M : matrix(_Xnew),
   /*print("matrix = ",_M),*/

  for i:1 thru (_l-1) do (
  /*for i:1 thru (_l+1) do (*/
    _Xnew : _X(_Xnew),
    dprint(3,"X(",i,") = ",_Xnew),
    _M : addrow(_M,_Xnew)
  ),


  print("M = ",_M ),

  /* take the determinant */
  _extactic : determinant(_M), 
  dprint(3,"determinant of M = ",_extactic),
  /* factorize, gfactor does factorization over the gaussian integers */
/*
  _extactic : gfactor(_extactic),
  dprint(3,"factorization = ",_extactic),
*/
return(_extactic)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/*  algorithm from Guillaume Cheze, computation of darboux polynomials and rational
    first integrals with bounded degree in polynomial time (Arxiv)
    input: polynomial derivation dy/dx=Q/P, with [y,x] and n an integer
    output: rational first integral with degree < n or: no rational first integral
            with degree < n exists
*/
/* ************************************************************************** */
Lagutinskii_Pereira(_P,_Q,_varlist,_n):=block([EcstaticCurve,EcstaticFactors,DarbouxPolynomials:[]],

  EcstaticCurve : Ecstatic(_P,_Q,_varlist,_n), print("curve = ",EcstaticCurve),
  EcstaticFactors: gfactor(EcstaticCurve), 
  if op(EcstaticFactors)="-" then EcstaticFactors:-EcstaticFactors, 
  for _f in args(EcstaticFactors) do (
    _Df : Dop(_P,_Q,_f), 
    
    /*DarbouxPolynomials:cons([_f,divide(_Df,_f)],DarbouxPolynomials) */
    if (ratsimp(gcd(_f,_Df)-_f)=0) then (
      _g : divide(_Df,_f),
       
      print("g = ",_g), 
      if (_g[2]=0) then DarbouxPolynomials : append([[_f,_g[1]]],DarbouxPolynomials), 
      print("Darboux=",DarbouxPolynomials) 
    )
  ),
/* note that we also need to compute the multiplicity, this will tell us if we have exponential factors or not */

/* note that the factorization is over integers */
return(DarbouxPolynomials)

);
/* ************************************************************************** */


/* ************************************************************************** */
/* compute solution of ode based on ecstatic curve */
/* ************************************************************************** */
ode1Darboux(_P,_Q,_varlist,_n):=block([niList,Sfg],


      Sfg : Lagutinskii_Pereira(_P,_Q,_varlist,_n), print("Sfg = ",Sfg),


     /* get the cofactors g from Sfg and multiply with the variable ni, i=1..length(Sfg) */
      niList : makelist(concat(n,i),i,length(Sfg)),
      dprint(3,"niList = ",niList),

      /* ********************************************************************************** */
      /* step 3, decide if there are constants ni, not all zero, such that sum(n_i*g_i) = 0 */
      /* ********************************************************************************** */
      dprint(1,"***** STEP 3 ***** "),
      Sum_nigi : apply("+",niList*map(rest,Sfg))[1],


/*
      Sum_nigi_originalVariables : lratsubst(map("=",varlist,original_variables),Sum_nigi),
      Sfg_originalVariables : lratsubst(map("=",varlist,original_variables),Sfg),
      Sum_nigi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sum_nigi_originalVariables),
      Sfg : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sfg_originalVariables),
*/

      ni : ode1CheckDarboux(Sfg,_varlist,niList,Sum_nigi),

      dprint(3,"sum_nigi = ",Sum_nigi),
      dprint(3,"Sfg = ",Sfg),
      dprint(3,"Vars = ",_varlist),

      if ni # [] then ( 
        if length(delete(0,ni)) # 0 then (
          EXIT : true,
          method: "firstIntegral",
          dprint(1," ***** FIRST INTEGRAL FOUND ***** "),
          return(method)
        )
      ),

      /* ********************************************************************************** */
      /* step 4: step 3 failed, now we construct a nonzero right hand side -(dP/dx + dQ/dy) and add to Sum_nigi */
      /* note we assume that varlist[1] is the dependent variable and varlist[2] is the dependent variable, this is prone to error! */
      /* ********************************************************************************** */
      dprint(1,"***** STEP 4 ***** "),
      dPdx_plus_dQdy : diff(_P,x) + diff(_Q,y),
      Sum_nigi : Sum_nigi - dPdx_plus_dQdy,
      dprint(3,"dPdx = ",dPdx_plus_dQdy),
      dprint(3,"sum_nigi = ",Sum_nigi),

/*
      Sum_nigi_originalVariables : lratsubst(map("=",varlist,original_variables),Sum_nigi),
      Sfg_originalVariables : lratsubst(map("=",varlist,original_variables),Sfg),

      Sum_nigi : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sum_nigi_originalVariables),
      Sfg : lratsubst(map("=",reverse(original_variables),reverse(varlist)),Sfg_originalVariables),
*/
      ni : ode1CheckDarboux(Sfg,_varlist,niList,Sum_nigi),

      dprint(3,"sum_nigi = ",Sum_nigi),
      dprint(3,"Sfg = ",Sfg),
      dprint(3,"Vars = ",_varlist),

      if ni # [] then ( 
        EXIT : true,
        method:"integratingFactor",
        dprint(1," ***** INTEGRATING FACTOR FOUND ***** "),
        return(method)
      ),

return(false)
)$

/* ************************************************************************** */
/* Differential operator assumes variables x,y */
/* ************************************************************************** */
Dop(_P,_Q,_v):= block([], 
_P*diff(_v,x)+_Q*diff(_v,y))$
/* ************************************************************************** */


/* ************************************************************************** */
/* convert sin,cos, csc, etc to tan. _expr can be a list                      */
/* ************************************************************************** */
Trig2Tan(_expr,_y,_x):=block([],
  /* convert [csc, sec, cot] to [sin,cos] */
  _expr : trigsimp(_expr),
  /* converts sin(2*x) etc to 2*sin(x)*cos(x) */
  _expr : trigexpand(_expr),

  _expr : subst(sin(_x)=tan(_x)/(sqrt(1+tan(_x)*tan(_x))),_expr),
  _expr : subst(sin(_y)=tan(_y)/(sqrt(1+tan(_y)*tan(_y))),_expr),

  _expr : subst(cos(_x)=1/(sqrt(1+tan(_x)*tan(_x))),_expr),
  _expr : subst(cos(_y)=1/(sqrt(1+tan(_y)*tan(_y))),_expr),

  return(_expr)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* convert sin,cos, csc, etc to var=tan(x/2). _expr can be a list             */
/* ************************************************************************** */
Trig2T(_expr,_x,_y,_varx,_vary):=block([],

  /* convert [csc, sec, cot] to [sin,cos] */
  _expr : trigsimp(_expr),
  /* converts sin(2*x) etc to 2*sin(x)*cos(x) */
  _expr : trigexpand(_expr),

  _expr : subst(sin(_x) = 2*_varx/(1+_varx*_varx), _expr),
  _expr : subst(sin(_y) = 2*_vary/(1+_vary*_vary), _expr),

  _expr : subst(cos(_x) =(_varx*_varx - 1)/(_varx*_varx+1), _expr),
  _expr : subst(cos(_y) =(_vary*_vary - 1)/(_vary*_vary+1), _expr),

  _expr : ratsimp(_expr),

  return(_expr)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* converts t=tan(x/2)  _expr can be a list                                   */
/* ************************************************************************** */
T2Trig(_expr,_x,_y,_varx,_vary) :=block([],

  _expr : subst(_varx = tan(_x/2), _expr),
  _expr : subst(_vary = tan(_y/2), _expr),
  
  _expr : radcan(trigsimp(_expr)),

  return(_expr)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* write ode1 to canonical form:                                              */
/* -write sin,cos,tan,cot, etc as sin,cos                                     */
/* -expand square roots                                                       */
/* ************************************************************************** */
ode1CanonicalForm(_ode,_y,_x):=block([],
  dprint(3,"start canonical form: _ode = ",_ode),
  /* try to solve explicitly in the derivative */
  _ode:solve(_ode,'diff(_y,_x)),
  _ode : _ode[1],

  dprint(3,"rhs = ",_ode), 
  _rhs:ratsimp(trigexpand(trigsimp(rhs(_ode)))),   /* trigsimp writes sec(x) as 1/cos(x) and tan(2*x) as sin(2*x)/cos(2*x), and trigexpand writes sin(2*x) as 2*sin(x)*cos(x) */
  dprint(3,"rhs = ",_rhs), 

  /* splits square roots sqrt(a*b) into sqrt(a)*sqrt(b) and sqrt(a/b) into sqrt(a)/sqrt(b) */
  _rhs : rootsexpand(_rhs),
  dprint(3,"rhs = ",_rhs), 
  /* TODO: what about general fractional powers? */
  /* ... */

  /* what about log functions? */
  /* what about sinh functions?*/
  /* etc... */

  return('diff(_y,_x)=_rhs)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* get the pfaffian form of the ode, i.e. if dx/dt=P, dy/dt=Q, then           */
/* dy/dx = Q/P   =>   Pdy = Qdx and we return P,Q                             */
/* ************************************************************************** */
ode1PfaffianForm(_ode,_y,_x):=block([_P,_Q],

  _ode : ratsimp(_ode),
  _Q : num(rhs(_ode)),
  _P : denom(rhs(_ode)),

  return([_P,_Q])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* check ode input                                                            */
/* ************************************************************************** */
odeType(_ode,_y,_x,ODEtype):=block([_rhs,_df,_df_x,_df_y,_P,_Q],

  if freeof('diff,_ode) then (dprint(0,"Error: no differential operator (diff) found!"), return(false)),
  if derivdegree(_ode,_y,_x) # 1 then (dprint(0,"No first order ODE found!"), return (false)), 

  _ode:solve(_ode,'diff(_y,_x)),
 
  if not listp(_ode) then (dprint(0,"Error: could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(false)),
  if length(_ode) > 1 then dprint(0,"warning: writing the ODE in the explicit form dy/dx=f(x,y) leads to multiple ODEs: ",_ode),

  _ode : _ode[1],
  if lhs(_ode)#('diff(_y,_x)) then (dprint(0,"could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(false)),

  /* we have to check if the ode contains general functions */
  if (heuristics=false) then (
    varlist : showratvars(rhs(_ode)), /* all free variables */
    varlist : sublist(varlist,lambda([_i],not(lfreeof(map(op,dependencies),_i)) or not(lfreeof(dependencies,_i)) or not(freeof('diff,diff(_i,_y))) or not(freeof('diff,diff(_i,_x))))),
    if varlist # [] then (
      dprint(0,"Error: Prelle-Singer method cannot handle general functions."),
      dprint(0,"try again with option 'heuristics=true"),
      return(false)
    )
  ),

  dprint(3,"rhs = ",_rhs),
 
  /* The P-S assumes the variables y,x to be independent */
  /* so we remove the possible dependency                */ 
  /* we have y(x) or x(y) and we want y,x */
/*
  if (radcan(diff(_y,_x)) # 0) or (radcan(diff(_x,_y))#0) then (
    print("removing x-y dependency"),
    Y_X_DEPEND:true, 
    _ode:subst(%x%,_x,subst(%y%,_y,_ode)), 
    LISTOFTERMS:subst(%x%,_x,subst(%y%,_y,LISTOFTERMS)),

    /* Pick all atoms for which gradient with respect to x,y was defined */ 
    /* so if we have f, then we can define df=diff(f,x) to deal with these functions */
    if ODEFI_GRAD_LIST # nil then (
      ODEFI_GRAD_LIST:subst(%x%,_x,subst(%y%,_y,ODEFI_GRAD_LIST)), 
      for _dfs in ODEFI_GRAD_LIST do (
        _df:lhs(_dfs),
        _df_x:diff(_df,_x),
        _df_y:diff(_df,_y), 
        if _df_x#0 or _df_y#0 then (
          apply('gradef,[_df,%x%,subst(%x%,_x,subst(%y%,_y,_df_x))]), 
          apply('gradef,[_df,%y%,subst(%x%,_x,subst(%y%,_y,_df_y))]) 
        ) 
      )
    )
  ) 
  else (%y%:_y,%x%:_x),
*/
  dprint(3,"ODE:",_ode),
  dprint(3,"x (independent variable) : ",_x),
  dprint(3,"y (dependent variable) : ",_y),

  /* dy/dx = M/N =Q/P*/ 
  /*_P:  ratcoeff(_ode,'diff(_y,_x),1),   */
  /*_Q: -ratsimp(_ode - _P*'diff(_y,_x)), */

  return(["explicit first order ode"])
)$
/* ************************************************************************** */


/* ************************************************************************* */
/* ***** check if f is an invariant algebraic curve of the ode         ***** */
/* ************************************************************************* */
isIAC(_f,_ode,_y,_x):=block([_P,_Q],
_ode : ode1CanonicalForm(_ode,_y,_x),
[_P,_Q] : ode1PfaffianForm(_ode,_y,_x),
return(Dop(_P,_Q,_f))
)$
/* ************************************************************************** */


/* ************************************************************************* */
/* ***** print expr only when flag<DEBUGFLAG                           ***** */
/* ************************************************************************* */
dprint(flag,[expr])::= if flag <= DEBUGFLAG then buildq ([expr], print (splice (expr)));
/* ************************************************************************* */
