/* ************************************************************************** */
/* *****     separable                                                  ***** */
/* *****                                                                ***** */
/* *****     Author: Nijso Beishuizen                                   ***** */
/* *****                                                                ***** */
/* ***** Description: routines to determine separable functions         ***** */
/* ***** Based on the paper by J.A. Cid, A simple method to find out    ***** */
/* ***** when an ordinary differential equation is separable,           ***** */
/* ***** International Journal of Mathematical Education in Science     ***** */
/* ***** and Technology Vol. 40 , Iss. 5,2009                           ***** */
/* ***** (http://www4.ujaen.es/~angelcid/Archivos/Papers/IJMEST.pdf)    ***** */
/* ************************************************************************** */
/* ************************************************************************** */
/* in general we want pdiff, (the input can be pdiff) */
/* but if you don't we can comment it and comment all instances of */
/* convert_to_diff in this file */
load(pdiff);
/* ************************************************************************** */
put('separable,002,'version)$
/* ************************************************************************** */

/* ***** print all statements with flag lower than DEBUGFLAG           ***** */
DEBUGFLAG:1$


/* ************************************************************************** */
/* input: an expression F(x,y)                          */
/* output: a list with separated functions [f(x),g(y)]  */
/* or [f(x),g(y),C]                                     */
/* or false when the expression is not separable        */
/* ************************************************************************** */
separable(_F,_x,_y,[options]) :=block([_dF,_S,_f,_g],

  splitConstant       : assoc('splitConstant,options,false), /* if true, if F(x,y)=C*f(x),g(y), the output will be [f,g,C] */
                                                             /* if false, if F(x,y)=C*f(x)*g(y), the output will be [f,g]  */       

  /* we need to make sure that P,Q are coprime, so we should check if they have shared factors.     */
  /* we can do extensive simplification to make sure that this is the case, or just assume that     */
  /* this is true: the user has to make sure that the input _F is simplified enough                 */
  _F1 : ratsimp(_F), /* ratsimp is unavoidable here to construct a proper P/Q expression ... */
  dprint(5,"expr = ",_F),

  /* preliminaries: check if freeof x or freeof y */
   /* ***** if the expression is independent of x,y then it is a constant and not separable  ***** */
  if freeof(_x,_y,_F1) then (
     dprint(5,"separable: expression is C"),
     if splitConstant then return([1,1,_F1]) else return([1,_F1])
  ),

  /* note that we always want the first factor to be free of the minus sign */
  /* ***** check if the expression depends only on y ***** */
  if freeof(_x,_F1) then (
     dprint(5,"separable: expression is f(y)"),
     _C : constant_factors(_F1,[y]),
     dprint(5,"C = ",_C),
     if splitConstant then return([1,ratsimp(_F1/_C),_C]) else return([1,_F1])
  ),

  /* ***** check if the expression depends only on x ***** */
  if freeof(_y,_F1) then (
     dprint(5,"separable: expression is f(x)"),
     _C : constant_factors(_F1,[x]),
     dprint(5,"C = ",_C),
    if(op(_F1)=op(-1)) then ( 
      if splitConstant then return([ratsimp(-_F1/_C),1,-_C]) else return([ratsimp(-_F1/_C),-_C]) 
    )
    else 
      if splitConstant then return([ratsimp(_F1/_C),1,_C]) else return([ratsimp(_F1/_C),_C])
  ),

  _P : num(_F1),
  _Q : denom(_F1),
  dprint(5,"F1=",_F1), 
  dprint(5,"P=",_P), 
  dprint(5,"Q=",_Q), 

  /* if P,Q are coprime functions, then F is separable if P and Q are separable */
  /* we could introduce this assumption to speed up the code significantly */
  /* first, some simple checks: check if Q is Q(x),Q(y) or Q(x,y) */

  /* we can now do a quick check for inseparable functions, for instance sqrt(x+y) or f(x*y) */
  /* e.g. kamke 1.338 has sqrt(y+x) terms */
  _ratvars : showratvars(_F1),
  dprint(5,"ratvars=",_ratvars),
  /* we assume that any expression that contains sqrt(f(x)+g(y)) is not separable */
  _L : sublist(_ratvars,lambda([i],not freeof(sqrt,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],op(i[1])="+")), 
  if _L # [] then (
    dprint(5,"unseparable function found: sqrt(f(x) + f(y))"),
    return(false)
  ),

  /* now check if we have sin(x*y) or cos(x*y) */
  _L : sublist(_ratvars,lambda([i],not freeof(sin,cos,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],i[1]=_x*_y)), /* only check for sin(x*y) or cos(x*y)*/ 
  if _L # [] then (
    dprint(5,"unseparable function found: sin(x*y) or cos(x*y)"),
    return(false)
  ),


  if not(freeof(_x,_y,_Q)) then (
    
    /* note, these two checks are easily captured by the third general separation of P/Q */
    if freeof(_x,_P) then (
      if freeof(_y,_Q) then (
       /* P(y)/Q(x) */
       dprint(5,"separable: expression is P(y)/Q(x)"),
       _cfp : constant_factors(_P,[_y]),
       _cfq : constant_factors(_Q,[_x]),
       if splitConstant then
         return([ratsimp(1/(_Q/_cfq)),ratsimp(_P/_cfp),_cfp/_cfq])
       else
         /* we only need to get rid of the constant in the f(x) term */
         return([ratsimp(1/(_Q/_cfq)),ratsimp(_P*_cfq)])
      ) 
    )
    else if freeof(_y,_P) then (
      if freeof(_x,_Q) then(
       /* P(x)/Q(y) */
       dprint(5,"separable: expression is P(x)/Q(y)"),
       _cfp : constant_factors(_P,[_x]),
       _cfq : constant_factors(_Q,[_y]),
       if splitConstant then
          return([ratsimp(_P/_cfp),ratsimp(1/(_Q/_cfq)),_cfp/_cfq])
       else
          return([ratsimp(_P/_cfp),ratsimp(_cfp/_Q)])
      )
    )
    else (
      /*P=P(x,y)*/
      _SP : separable(_P,_x,_y,'splitConstant=splitConstant),
      if (_SP=false) then return(false),
      _SQ : separable(_Q,_x,_y,'splitConstant=splitConstant),
      if (_SQ=false) then return(false),
      if splitConstant then
        return([ratsimp(_SP[1]*_SQ[1]),ratsimp(_SP[2]*_SQ[2]),_SP[3]*_SQ[3]])
      else
        return([ratsimp(_SP[1]*_SQ[1]),ratsimp(_SP[2]*_SQ[2])])
    )
  ),
  /* if we end up here, then Q is free of x and y, so we basically have P(x,y)/C */  
 
  /* we use the ratsimp expression if it is smaller (or not much larger) than the F-expression */
  if slength(string(_F1)) < 1.5*slength(string(_F)) then _F : _F1,
 

  dprint(5,"differentiating"),
  _dF : diff(_F,_x),
  dprint(5,"dividing"),
  _S : _dF/_F,
  dprint(5,"divided: S = ",_S),

  _S : simplify(_S),
  dprint(5,"S = ",_S),

  if freeof(_y,_S) then (
  /* F is separable*/
    dprint(5,"f is separable"),
    _f : exp(integrate(_S,_x)),
    _f : simplify(_f),
    _dF : diff(_F,_y),
    _S : _dF/_F,
    _S : simplify(_S),
    if freeof(_x,_S) then (
      dprint(5,"g was successfully found"),
      _g : exp(integrate(_S,_y)),
      _g : simplify(_g)
    ) else (
      dprint(0,"FATAL ERROR! WAS NOT ABLE TO SEPARATE Y FROM THE SEPARABLE FUNCTION ",_F),
      return(false)
    )
  ) else return(false),

  /* note that the residue can be a non-unity constant */
  _Res : simplify(_F/(_f*_g)),
  dprint(5,"residue = ",_Res),
  if (freeof(_x,_Res) and freeof(_y,_Res)) then (
    dprint(5,"separability verified"),
    /* add the constant factor only when we do not want to split the constant */
    if not(splitConstant) then _g : _g*_Res
  )
  else (
    dprint(0,"error: could not validate separable function! F=f(x)*g(y), F,f,g = ",simplify(_F),", ",simplify(_f),", ",simplify(_g)),
    dprint(0,"error: could not validate separable function! F=f(x)*g(y), F,f,g = ",_F,", ",_f,", ",_g),
    return(false)
  ),
 

  /* this was the old way. with the new algorithm, the constant factor is obtained using the residue */
  /* determine the constant factor in front of _f */
  /* _cf : constant_factors(_f,[_x]),*/

 /*  _f : ratsimp(_f/_cf),*/
 /*  _g : ratsimp(_g*_cf),*/
  if splitConstant then
    return([_f,_g,_Res])
  else
    return([_f,_g])
)$


/* ************************************************************************** */
/* input: an expression F(x,y)                          */
/* output: true if input expression is separable        */
/* or false when the expression is not separable        */
/* ************************************************************************** */
isSeparable(_F,_x,_y) :=block([_dF,_S,_f,_g],


  /* we need to make sure that P,Q are coprime, so we should check if they have shared factors.     */
  /* we can do extensive simplification to make sure that this is not the case, or just assume that */
  /* this is true: the user has to make sure that the input _F is simplified enough                 */
  _F1 : ratsimp(_F), /* ratsimp is unavoidable here to construct a proper P/Q expression ... */
  dprint(5,"expr = ",_F),

  /* preliminaries: check if freeof x or freeof y */
   /* ***** if the expression is independent of x,y then it is a constant and not separable  ***** */
  if freeof(_x,_y,_F1) then (
     dprint(5,"separable: expression is C"),
     return(true) 
  ),

  /* note that we always want the first factor to be free of the minus sign */
  /* ***** check if the expression depends only on y ***** */
  if freeof(_x,_F1) then (
     dprint(5,"separable: expression is f(y)"),
     return(true)
  ),

  /* ***** check if the expression depends only on x ***** */
  if freeof(_y,_F1) then (
     dprint(5,"separable: expression is f(x)"),
     return(true)
  ),

  _P : num(_F1),
  _Q : denom(_F1),
  _ratvars : showratvars(_F1),
  /* we assume that any expression that contains sqrt(f(x)+g(y)) is not separable */
  _L : sublist(_ratvars,lambda([i],not freeof(sqrt,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],op(i[1])="+")), 
  if _L # [] then (
    dprint(5,"unseparable function found: sqrt(f(x) + f(y))"),
    return(false)
  ),
  /* now check if we have sin(x*y) or cos(x*y) */
  _L : sublist(_ratvars,lambda([i],not freeof(sin,cos,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],i[1]=_x*_y)), /* only check for sin(x*y) or cos(x*y)*/ 
  if _L # [] then (
    dprint(5,"unseparable function found: sin(x*y) or cos(x*y)"),
    return(false)
  ),

  if not(freeof(_x,_y,_Q)) then (
    
    /* note, these two checks are easily captured by the third general separation of P/Q */
    if freeof(_x,_P) then (
      if freeof(_y,_Q) then (
       /* P(y)/Q(x) */
       dprint(5,"separable: expression is P(y)/Q(x)"),
       return(true)
      ) 
    )
    else if freeof(_y,_P) then (
      if freeof(_x,_Q) then(
       /* P(x)/Q(y) */
       dprint(5,"separable: expression is P(x)/Q(y)"),
       returntrue()
      )
    )
    else (
      /*P=P(x,y)*/
      _SP : isSeparable(_P,_x,_y),
      dprint(5,"rational separation: P=",_SP), 
      if (_SP=false) then return(false),
      _SQ : isSeparable(_Q,_x,_y),
      dprint(5,"rational separation: Q=",_SQ), 
      if (_SQ=false) then return(false),
      return(true)
    )
  ),
  /* if we end up here, then Q is free of x and y, so we basically have P(x,y)/C */  
 
  /* we use the ratsimp expression if it is smaller (or not much larger) than the F-expression */
  if slength(string(_F1)) < 1.5*slength(string(_F)) then _F : _F1,
 

  dprint(5,"differentiating"),
  _dF : diff(_F,_x),
  dprint(5,"dividing"),
  _S : _dF/_F,
  dprint(5,"divided: S = ",_S),

  _S : simplify(_S),
  dprint(5,"S = ",_S),

  if freeof(_y,_S) then (
  /* F is separable*/
    dprint(5,"f is separable"),
    return(true)
  )
  else return(false)

)$


/* ************************************************************************** */
/* ----- simple method of finding the constant factor in front of an equation */
/* step 1: construct a set of args(expr)                                      */
/* step 2: determine the subset containing only constants                     */
/* ************************************************************************** */
constant_factors(_expr,_varlist) := block([inflag:true,_constantfactors:1,_oldratvars,_C1:1],

  if lfreeof(_varlist,_expr) then return(_expr),
  if mapatom(_expr) then return(1),

  if not(listp(_varlist)) then _varlist : [_varlist],

  _oldratvars : ratvars,
  ratvars : _varlist, /* this was done globally elsewhere, should we do it only locally? */

  /* first we find terms C*f + C*g + C*h */
  _expr : ratexpand(_expr),
  _G([L]):=gcd(L[1],L[2]),
  if op(_expr)="+" then (
     _arglist:args(_expr),
     _L : map(lambda([_i],constant_factors(_i,_varlist)),_arglist),
     /* determine if there is a shared minus sign */
     _C1 : lreduce(_G,_L),
     _W : unique(map(string,_L)),
     if length(_W)=1 then (
       _W : _W[1],
       if (substring(_W,1,2)="-") then (
         _C1 : -_C1
       )
     )
  ), 

  _expr : ratsimp(_expr/_C1),

/* moved to the top*/
/*
  if lfreeof(_varlist,_expr) then
    _constantfactors:_expr
*/  
  if not mapatom(_expr) and op(_expr)="*"
  /* we know that the internal dependent variable is _x,and we want expr to be free of x */
  /* constantp doesn't knowthat abs(a) is constant */
  then
    _constantfactors : xreduce("*",listify(subset(setify(args(_expr)),lambda([_u],lfreeof(_varlist,_u))))),

  ratvars : _oldratvars,

  return(_constantfactors*_C1)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* ************************************************************************** */
simplify(_S):=block([_N,_Nnew,_Snew],
  
  /*_N : length(nrOps(_S)),*/
  _N : slength(string(_S)),

  _Snew : ratsimp(_S),

  /*_Nnew : length(nrOps(_Snew)),*/
  _Nnew : slength(string(_Snew)),
  if _Nnew < _N then _S : _Snew,


  if not freeof(sin,cos,tan,_S) then _S : trigexpand(convert_to_diff(_S)),
  if not freeof(sin,cos,tan,_S) then _S : trigsimp(convert_to_diff(_S)),
  if not freeof(sin,cos,tan,_S) then _S : trigreduce(convert_to_diff(_S)),
/*
  if not freeof(sin,cos,tan,_S) then _S : trigexpand((_S)),
  if not freeof(sin,cos,tan,_S) then _S : trigsimp((_S)),
  if not freeof(sin,cos,tan,_S) then _S : trigreduce((_S)),
*/
  if not freeof(%e,log,_S) then _S : radcan(_S),

  return(_S)
)$


/*****************************************************************************************************/
/* ----- calculates the number of operators in the expression ----- */
/* ----- this is a simple measure of complexity               ----- */
/*****************************************************************************************************/
/* note: this is incredibly slow */
nrOps(_expression):=
 block( [ _counter:0],
        dprint(6,"expression:",_expression),
        nrOpsPriv (_expression, [])
       )$

nrOpsPriv(_expression, _opList) :=
 block ( [_x, _args, _newList],
        /* if expression is an atom, then we return opList */
        if atom(_expression)
           then _opList
           else (
              _x:    op(_expression),
              _args: args(_expression),
              /* add the operators to the opList */
              _newList: cons(_x, _opList),
              for _arg in _args do
                /* also expand all the subexpressions and count the operators */
                _newList: nrOpsPriv(_arg, _newList),
              _newList
             )
        )$


/* ************************************************************************* */
/* ***** print expr only when flag<DEBUGFLAG                           ***** */
/* ************************************************************************* */
dprint(flag,[_expr])::= if flag <= DEBUGFLAG then buildq ([_expr], print (splice (_expr)))$
/* ************************************************************************* */
