/* ************************************************************************** */
/* *****     separable                                                  ***** */
/* *****                                                                ***** */
/* *****     Author: Nijso Beishuizen                                   ***** */
/* *****                                                                ***** */
/* ***** Description: routines to determine separable functions         ***** */
/* ***** Based on the paper by J.A. Cid, A simple method to find out    ***** */
/* ***** when an ordinary differential equation is separable,           ***** */
/* ***** International Journal of Mathematical Education in Science     ***** */
/* ***** and Technology Vol. 40 , Iss. 5,2009                           ***** */
/* ***** (http://www4.ujaen.es/~angelcid/Archivos/Papers/IJMEST.pdf)    ***** */
/* ************************************************************************** */
/* ************************************************************************** */
/* in general we want pdiff, (the input can be pdiff) */
/* but if you don't we can comment it and comment all instances of */
/* convert_to_diff in this file */
/*load(pdiff);*/
/* ************************************************************************** */
put('separable,002,'version)$
/* ************************************************************************** */

/* ***** print all statements with flag lower than DEBUGFLAG           ***** */
DEBUGFLAG:5$
/* ***** the maximum length of an expression(using the length of the string) that we will consider for separability ***** */
/* ***** default: 2000 ***** */
/* note that setting this to a higher value will increase the computational time (sometimes to infinite time), but might lead to a successfull solution in the end*/
/* setting this value to 100,000 led to extra solutions found, higher values not */
MAX_LENGTH_FOR_SEPARABILITY:10000$
MAX_LENGTH_FOR_SIMPLIFICATION:10000$

ratfac:true$
radsubstflag:true$

/* ************************************************************************** */
/* input: an expression F(x,y)                          */
/* output: a list with separated functions [f(x),g(y)]  */
/* or [f(x),g(y),C]                                     */
/* or false when the expression is not separable        */
/* ************************************************************************** */
separable(_F,_x,_y,[options]) :=block([_F1,_C,_dF,_S,_f,_g,_P,_Q,_ratvars,_L,_cfp,_cfq,_SP,_SQ,_Res],

  splitConstant       : assoc('splitConstant,options,false), /* if true, if F(x,y)=C*f(x),g(y), the output will be [f,g,C] */
                                                             /* if false, if F(x,y)=C*f(x)*g(y), the output will be [f,g]  */       

  /* we need to make sure that P,Q are coprime, so we should check if they have shared factors.     */
  /* we can do extensive simplification to make sure that this is the case, or just assume that     */
  /* this is true: the user has to make sure that the input _F is simplified enough                 */
  _F1 : ratsimp(_F), /* ratsimp is unavoidable here to construct a proper P/Q expression ... */
  dprint(5,"expr F = ",grind(_F1)),



  /* preliminaries: check if freeof x or freeof y */
   /* ***** if the expression is independent of x,y then it is a constant and not separable  ***** */
  if freeof(_x,_y,_F1) then (
     dprint(5,"separable: expression is C"),
     if splitConstant then return([1,1,_F1]) else return([1,_F1])
  ),

  /* note that we always want the first factor to be free of the minus sign */
  /* ***** check if the expression depends only on y ***** */
  if freeof(_x,_F1) then (
     dprint(5,"separable: expression is f(y)"),
     _C : constant_factors(_F1,[_y]),
     dprint(5,"C = ",_C),
     if splitConstant then return([1,ratsimp(_F1/_C),_C]) else return([1,_F1])
  ),

  /* ***** check if the expression depends only on x ***** */
  if freeof(_y,_F1) then (
     dprint(5,"separable: expression is f(x)"),
     _C : constant_factors(_F1,[_x]),
     dprint(5,"C = ",_C),
    if(signum(_F1)=-1) then ( 
      if splitConstant then return([ratsimp(-_F1/_C),1,-_C]) else return([ratsimp(-_F1/_C),-_C]) 
    )
    else 
      if splitConstant then return([ratsimp(_F1/_C),1,_C]) else return([ratsimp(_F1/_C),_C])
  ),


  /* very quick preliminary test to see if it is immediately separable */
  if op(_F1)="*" then (
    dprint(5,"we have product terms"),
    _L : args(_F1),
    dprint(5,"L = ",_L),
    _Res:sublist(_L,lambda([_i],not freeof(_y,_i) and not freeof(_x,_i))),
    dprint(5,"res = ",_Res),
    if _Res=[] then (
      _g:apply("*",sublist(_L,lambda([_i],freeof(_x,_i) and not freeof(_y,_i)))),
      _f:apply("*",sublist(_L,lambda([_i],freeof(_y,_i) and not freeof(_x,_i)))),
      _C:apply("*",sublist(_L,lambda([_i],freeof(_y,_i) and freeof(_x,_i)))),
      dprint(5,"separable, f=",_f),
      dprint(5,"separable, g=",_g),
      if splitConstant then return([_f,_g,_C])
      else return ([_f,_g*_C])
    )
  ), 


  /* ***** we have a maximum limit for the expression, long expressions take forever to separate ***** */
  _lS : slength(string(_F1)),  
  dprint(5,"   length S = ",_lS),  
  if (_lS>MAX_LENGTH_FOR_SEPARABILITY) then (
      dprint(1,"Warning: subexpression is too long to consider separability. Length = ",_lS),
      dprint(1,"Putting separable=false. "),
      dprint(1,"If you want to try anyway, put MAX_LENGTH_FOR_SEPARABILITY to a higher value. Current value: ",MAX_LENGTH_FOR_SEPARABILITY),
      return(false)
  ),

  _P : num(_F1),
  _Q : denom(_F1),
  dprint(5,"F1=",_F1), 
  dprint(5,"P=",_P), 
  dprint(5,"Q=",_Q), 

  /* if P,Q are coprime functions, then F is separable if P and Q are separable */
  /* we could introduce this assumption to speed up the code significantly */
  /* first, some simple checks: check if Q is Q(x),Q(y) or Q(x,y) */

  /* we can now do a quick check for inseparable functions, for instance sqrt(x+y) or f(x*y) */
  /* e.g. kamke 1.338 has sqrt(y+x) terms */
  _ratvars : showratvars(_F1),
  dprint(5,"ratvars=",_ratvars),
  /* we assume that any expression that contains sqrt(f(x)+g(y)) is not separable */
  _L : sublist(_ratvars,lambda([i],not freeof(sqrt,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],op(i[1])="+")), 
  if _L # [] then (
    dprint(5,"unseparable function found: sqrt(f(x) + f(y))"),
    return(false)
  ),

  /* now check if we have sin(x*y) or cos(x*y) */
  _L : sublist(_ratvars,lambda([i],not freeof(sin,cos,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],i[1]=_x*_y)), /* only check for sin(x*y) or cos(x*y)*/ 
  if _L # [] then (
    dprint(5,"unseparable function found: sin(x*y) or cos(x*y)"),
    return(false)
  ),


  if not(freeof(_x,_y,_Q)) then (
    
    /* note, these two checks are easily captured by the third general separation of P/Q */
    if freeof(_x,_P) then (
      if freeof(_y,_Q) then (
       /* P(y)/Q(x) */
       dprint(5,"separable: expression is P(y)/Q(x)"),
       _cfp : constant_factors(_P,[_y]),
       _cfq : constant_factors(_Q,[_x]),
       if splitConstant then
         return([ratsimp(1/(_Q/_cfq)),ratsimp(_P/_cfp),_cfp/_cfq])
       else
         /* we only need to get rid of the constant in the f(x) term */
         return([ratsimp(1/(_Q/_cfq)),ratsimp(_P*_cfq)])
      ) 
    )
    else if freeof(_y,_P) then (
      if freeof(_x,_Q) then(
       /* P(x)/Q(y) */
       dprint(5,"separable: expression is P(x)/Q(y)"),
       _cfp : constant_factors(_P,[_x]),
       _cfq : constant_factors(_Q,[_y]),
       if splitConstant then
          return([ratsimp(_P/_cfp),ratsimp(1/(_Q/_cfq)),_cfp/_cfq])
       else
          return([ratsimp(_P/_cfp),ratsimp(_cfp/_Q)])
      )
    )
    else (
      /*P=P(x,y)*/
       dprint(5,"separable: expression is P(x,y)/Q(y)"),
      _SP : separable(_P,_x,_y,'splitConstant=splitConstant),
      dprint(5,"sP = ",_SP),
      if (_SP=false) then return(false),
      _SQ : separable(_Q,_x,_y,'splitConstant=splitConstant),
      dprint(5,"sQ = ",_SQ),
      if (_SQ=false) then return(false),
      if splitConstant then
        return([ratsimp(_SP[1]/_SQ[1]),ratsimp(_SP[2]/_SQ[2]),_SP[3]/_SQ[3]])
      else
        return([ratsimp(_SP[1]/_SQ[1]),ratsimp(_SP[2]/_SQ[2])])
    )
  ),
  /* if we end up here, then Q is free of x and y, so we basically have P(x,y)/C */  
 
  /* we use the ratsimp expression if it is smaller (or not much larger) than the F-expression */
  if slength(string(_F1)) < 1.5*slength(string(_F)) then _F : _F1,
 

  dprint(5,"differentiating"),
  _dF : diff(_F,_x),
  dprint(5,"dividing"),
  _S : _dF/_F,
  dprint(5,"divided: S = ",_S),

  if not freeof(_y,_S) then _S : simplify(_S),
  dprint(5,"S = ",_S),

  if freeof(_y,_S) then (
  /* F is separable*/
    dprint(5,"f is separable"),
    _f : exp(integrate(_S,_x)),
    _f : simplify(_f),
    dprint(5,"f:",grind(_f)),
    _dF : diff(_F,_y),
    _S : _dF/_F,
    if not freeof(_x,_S) then _S : simplify(_S),
    if freeof(_x,_S) then (
      dprint(5,"g was successfully found"),
      _g : exp(integrate(_S,_y)),
      dprint(5,"g:",grind(_g)),
      _g : simplify(_g)
    ) else (
      dprint(0,"FATAL ERROR! WAS NOT ABLE TO SEPARATE Y FROM THE SEPARABLE FUNCTION ",_F),
      return(false)
    )
  ) else return(false),

  /* note that the residue can be a non-unity constant */
  _Res : simplify(_F/(_f*_g)),
  dprint(5,"residue = ",grind(_Res)),
  if (freeof(_x,_Res) and freeof(_y,_Res)) then (
    dprint(5,"separability verified"),
    /* add the constant factor only when we do not want to split the constant */
    if not(splitConstant) then _g : _g*_Res
  )
  else (
    dprint(1,"Warning: could not validate separable function! F=f(x)*g(y), F,f,g = ",simplify(_F),", ",simplify(_f),", ",simplify(_g)),
    dprint(1,"Warning: could not validate separable function! F=f(x)*g(y), F,f,g = ",_F,", ",_f,", ",_g),
    dprint(1,"Trying division procedure..."),
    _g : simplify(_F/_f),    
    if freeof(_x,_g) then (
      dprint(1,"Separation was successful using division procedure"),
      if (splitConstant) then(
        _Res : constant_factors(_g,[_y]),
        _g:ratsimp(_g/_Res),
        dprint(0,"Constant factor = ",_Res)
      )
    ) else (    
      dprint(0,"Error: validation of separability failed")
    ),
    /* add the constant factor only when we do not want to split the constant */
    if not(splitConstant) then _g : _g*_Res
  ),
 

  /* this was the old way. with the new algorithm, the constant factor is obtained using the residue */
  /* determine the constant factor in front of _f */
  /* _cf : constant_factors(_f,[_x]),*/

 /*  _f : ratsimp(_f/_cf),*/
 /*  _g : ratsimp(_g*_cf),*/
  if splitConstant then
    return([_f,_g,_Res])
  else
    return([_f,_g])
)$


/* ************************************************************************** */
/* input: an expression F(x,y)                          */
/* output: true if input expression is separable        */
/* or false when the expression is not separable        */
/* ************************************************************************** */
isSeparable(_F,_x,_y) :=block([_F1,_P,_Q,_L,_SP,_SQ,_dF,_S,_f,_g],


  /* we need to make sure that P,Q are coprime, so we should check if they have shared factors.     */
  /* we can do extensive simplification to make sure that this is not the case, or just assume that */
  /* this is true: the user has to make sure that the input _F is simplified enough                 */
  _F1 : ratsimp(_F), /* ratsimp is unavoidable here to construct a proper P/Q expression ... */
  dprint(5,"expr = ",_F),

  /* preliminaries: check if freeof x or freeof y */
   /* ***** if the expression is independent of x,y then it is a constant and not separable  ***** */
  if freeof(_x,_y,_F1) then (
     dprint(5,"separable: expression is C"),
     return(true) 
  ),

  /* note that we always want the first factor to be free of the minus sign */
  /* ***** check if the expression depends only on y ***** */
  if freeof(_x,_F1) then (
     dprint(5,"separable: expression is f(y)"),
     return(true)
  ),

  /* ***** check if the expression depends only on x ***** */
  if freeof(_y,_F1) then (
     dprint(5,"separable: expression is f(x)"),
     return(true)
  ),

  _P : num(_F1),
  _Q : denom(_F1),
  _ratvars : showratvars(_F1),
  /* we assume that any expression that contains sqrt(f(x)+g(y)) is not separable */
  _L : sublist(_ratvars,lambda([i],not freeof(sqrt,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],op(i[1])="+")), 
  if _L # [] then (
    dprint(5,"unseparable function found: sqrt(f(x) + f(y))"),
    return(false)
  ),
  /* now check if we have sin(x*y) or cos(x*y) */
  _L : sublist(_ratvars,lambda([i],not freeof(sin,cos,dispform(i,all)))),
  _L : map(args,_L),
  _L:sublist(_L,lambda([i],not freeof(_x,i) and not freeof(_y,i) )),  
  _L:sublist(_L,lambda([i],i[1]=_x*_y)), /* only check for sin(x*y) or cos(x*y)*/ 
  if _L # [] then (
    dprint(5,"unseparable function found: sin(x*y) or cos(x*y)"),
    return(false)
  ),

  if not(freeof(_x,_y,_Q)) then (
    
    /* note, these two checks are easily captured by the third general separation of P/Q */
    if freeof(_x,_P) then (
      if freeof(_y,_Q) then (
       /* P(y)/Q(x) */
       dprint(5,"separable: expression is P(y)/Q(x)"),
       return(true)
      ) 
    )
    else if freeof(_y,_P) then (
      if freeof(_x,_Q) then(
       /* P(x)/Q(y) */
       dprint(5,"separable: expression is P(x)/Q(y)"),
       returntrue()
      )
    )
    else (
      /*P=P(x,y)*/
      _SP : isSeparable(_P,_x,_y),
      dprint(5,"rational separation: P=",_SP), 
      if (_SP=false) then return(false),
      _SQ : isSeparable(_Q,_x,_y),
      dprint(5,"rational separation: Q=",_SQ), 
      if (_SQ=false) then return(false),
      return(true)
    )
  ),
  /* if we end up here, then Q is free of x and y, so we basically have P(x,y)/C */  
 
  /* we use the ratsimp expression if it is smaller (or not much larger) than the F-expression */
  if slength(string(_F1)) < 1.5*slength(string(_F)) then _F : _F1,
 

  dprint(5,"differentiating"),
  _dF : diff(_F,_x),
  dprint(5,"dividing"),
  _S : _dF/_F,
  dprint(5,"divided: S = ",_S),

  _S : simplify(_S),
  dprint(5,"S = ",_S),

  if freeof(_y,_S) then (
  /* F is separable*/
    dprint(5,"f is separable"),
    return(true)
  )
  else return(false)

)$


/* ************************************************************************** */
/* ----- simple method of finding the constant factor in front of an equation */
/* step 1: construct a set of args(expr)                                      */
/* step 2: determine the subset containing only constants                     */
/* ************************************************************************** */
constant_factors(_expr,_varlist) := block([inflag:true,_constantfactors:1,_oldratvars,_C1:1,_G,_oldratvars_arglist,_L,_W],
/* note: make function G local*/

  if lfreeof(_varlist,_expr) then return(_expr),
  if mapatom(_expr) then return(1),

  if not(listp(_varlist)) then _varlist : [_varlist],

  _oldratvars : ratvars,
  ratvars : _varlist, /* this was done globally elsewhere, should we do it only locally? */

  /* first we find terms C*f + C*g + C*h */
  _expr : ratexpand(_expr),
  _G([L]):=gcd(L[1],L[2]),
  if op(_expr)="+" then (
     _arglist:args(_expr),
     _L : map(lambda([_i],constant_factors(_i,_varlist)),_arglist),
     /* determine if there is a shared minus sign */
     _C1 : lreduce(_G,_L),
     _W : unique(map(string,_L)),
     if length(_W)=1 then (
       _W : _W[1],
       if (substring(_W,1,2)="-") then (
         _C1 : -_C1
       )
     )
  ), 

  _expr : ratsimp(_expr/_C1),

/* moved to the top*/
/*
  if lfreeof(_varlist,_expr) then
    _constantfactors:_expr
*/  
  if not mapatom(_expr) and op(_expr)="*"
  /* we know that the internal dependent variable is _x,and we want expr to be free of x */
  /* constantp doesn't knowthat abs(a) is constant */
  then
    _constantfactors : xreduce("*",listify(subset(setify(args(_expr)),lambda([_u],lfreeof(_varlist,_u))))),

  ratvars : _oldratvars,

  return(_constantfactors*_C1)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* ************************************************************************** */
simplify(_S):=block([_N,_Nnew,_Snew,_ratvars,_lS],

  /* simplify unfactored subexpressions like sqrt(f+g)/(fg+g^2) -> 1/sqrt(f+g) that are not factored */

  /* ***** we have a maximum limit for the expression, long expressions take forever to separate ***** */
  _lS : slength(string(_S)),  
  dprint(5,"   length S = ",_lS),  
  if (_lS>MAX_LENGTH_FOR_SIMPLIFICATION) then (
      dprint(1,"Warning: subexpression is too long to consider separability. Length = ",_lS),
      dprint(1,"Returning original expression..."),
      dprint(1,"If you want to try anyway, put MAX_LENGTH_FOR_SIMPLIFICATION to a higher value. Current value: ",MAX_LENGTH_FOR_SIMPLIFICATION),
      return(_S)
  ),


  _ratvars : showratvars(_S),
  dprint(5,"ratvars = ",_ratvars),
  /* we use length of expression as a simple measure for complexity to check for expression swell*/
  _N : slength(string(_S)),
/*
  dprint(5,"s=",grind(_S)),
  dprint(5,"s=",grind(ratsimp(_S))),
  dprint(5,"s=",grind(ratsimp(ratexpand(_S)))),
  dprint(5,"s=",grind(ratsimp(factor(_S)))),
  dprint(5,"s=",grind(factor(ratsimp(_S)))),
  dprint(5,"s=",grind(fullratsimp(_S))),
  ratfac:true,dprint(5,"s=",grind(ratsimp(_S))),ratfac:false,
  radsubstflag:true,dprint(5,"s=",grind(ratsimp(_S))),radsubstflag:false,
  _Snew : fullratsimp(_S),
*/
  _Snew : fullratsimp(_S),
  _Nnew : slength(string(_Snew)),
  /*dprint(5,"   N,Nnew = ",_N," ",_Nnew),  */
  if _Nnew < 1.4*_N then (_S : _Snew, _N : slength(string(_S))),

dprint(5,"S=",_S),
  /* if we have trig functions, we only want to simplify if they depend on x or y */ 
  if sublist(_ratvars,lambda([_i],not freeof(sin,cos,tan,_i) and not freeof(_x,_y,_i))) # [] then (
    _Snew : trigreduce(_Snew),  /* reduces again */
    _Snew : trigsimp(_S),       /* writes sec -> 1/cos and tan(2x) -> sin(2x)/cos(2x)*/
    _Snew : trigexpand(_Snew),  /* writes sin(2x) as 2sin(x)cos(x) */
    _Snew : trigsimp(_Snew),    /* trigsimp again, this improves the probability of success of simplification! */

    _Nnew : slength(string(_Snew)),
    /*dprint(5,"trig,   N,Nnew = ",_N," ",_Nnew),  */
    if _Nnew < 1.4*_N then (_S : _Snew, _N : slength(string(_S)))
  ),
dprint(5,"S=",_S),

  if sublist(_ratvars,lambda([_i],not freeof(asinh,acosh,_i) and not freeof(_x,_y,_i))) # [] then (
    _Snew : logarc(_Snew),
    _Nnew : slength(string(_Snew)),
    /*dprint(5,"trigh   N,Nnew = ",_N," ",_Nnew),  */
    if _Nnew < 1.4*_N then (_S : _Snew, _N : slength(string(_S)))
  ),

  if sublist(_ratvars,lambda([_i],not freeof(%e,log,_i) and not freeof(_x,_y,_i))) # [] then (
    _Snew : radcan(_S),
    _Nnew : slength(string(_Snew)),
    /*dprint(5,"log   N,Nnew = ",_N," ",_Nnew),  */
    if _Nnew < 1.4*_N then (_S : _Snew, _N : slength(string(_S)))
  ),

  return(_S)
)$


/*****************************************************************************************************/
/* ----- calculates the number of operators in the expression ----- */
/* ----- this is a simple measure of complexity               ----- */
/*****************************************************************************************************/
/* note: this is incredibly slow */
nrOps(_expression):=
 block( [ _counter:0],
        dprint(6,"expression:",_expression),
        nrOpsPriv (_expression, [])
       )$

nrOpsPriv(_expression, _opList) :=
 block ( [_x, _args, _newList],
        /* if expression is an atom, then we return opList */
        if atom(_expression)
           then _opList
           else (
              _x:    op(_expression),
              _args: args(_expression),
              /* add the operators to the opList */
              _newList: cons(_x, _opList),
              for _arg in _args do
                /* also expand all the subexpressions and count the operators */
                _newList: nrOpsPriv(_arg, _newList),
              _newList
             )
        )$

/*****************************************************************************************************/
/* ----- creates a list of user defined functions from expr. the functions should not have any properties
         with the possible exception of noun                                                   ----- */
/*****************************************************************************************************/
listUDF(_expr):= block( [ _counter:0,listUDF:[]],
        listUDFPriv (_expr, []),
        return(unique(listUDF))
)$

listUDFPriv(_expr, _opList) :=
 block ( [_x, _args, _newList],
        if atom(_expr) then ( 
           _opList 
        )
        else if udf(_expr) then (
          listUDF: cons(_expr,listUDF) 
        )
        else ( 
          _x:    op(_expr),
          _args: args(_expr),
          /* add the operators to the opList */
          _newList: cons(_x, _opList),
          for _arg in _args do _newList: listUDFPriv(_arg, _newList),
          _newList
        )
)$


listUDFGeneral(_expr):= block( [ _counter:0,listUDF:[]],
        listUDFGeneralPriv (_expr, []),
        return(unique(listUDF))
)$

listUDFGeneralPriv(_expr, _opList) :=
 block ( [_x, _args, _newList],
        if atom(_expr) then ( 
           _opList 
        )
        else if udfGeneral(_expr) then (
          listUDF: cons(_expr,listUDF) 
        )
        else (
          _x:    op(_expr),
          _args: args(_expr),
          /* add the operators to the opList */
          _newList: cons(_x, _opList),
          for _arg in _args do _newList: listUDFGeneralPriv(_arg, _newList),
          _newList
        )
)$

simplifyingp(_f):= symbolp(_f) and is(?get(_f,?operators)=false)$

/*udf(_f):=not(stringp(op(_f)) or symbolp(op(_f)) or (simplifyingp(op(_f))))$*/
/* a user defined function is: 
     not a a string, just like sin(x), but not like x 
     a symbolp, like sin(x), but not like x
     a function with no properties
*/



 
/*udf(_f):=not(stringp(op(_f))) and (symbolp(op(_f))) and (apply(properties,[op(_f)])=[] or apply(properties,[op(_f)])=[noun])$*/
/* returns true if it is a udf*/
udf(_f):=not(stringp(op(_f))) and (symbolp(op(_f))) and simplifyingp(op(_f)) and not ?fboundp(op(_f)) $

/* general functions, including sin(a*x+b*y) */
/* we do not want diff() stuff here, they are usually udf and we do not support unevaluated diffs for known functions */
udfGeneral(_f):=not(stringp(op(_f))) and (symbolp(op(_f))) and not ?fboundp(op(_f)) and not(op(_f)=op(diff(__f1(__x),__x)))$





listGDF(_expr,_y,_x):= block( [ _counter:0,listGDF:[]],
        listGDFPriv (_expr, _y,_x, []),
        return(unique(listGDF))
)$

listGDFPriv(_expr, _y,_x, _opList) :=
 block ( [_op, _args, _newList],
        if atom(_expr) then ( 
           _opList 
        )
        else if gdfGeneral1(_expr,_y,_x) then (
          listGDF: cons(_expr,listGDF) 
        )
        else (
          _op:    op(_expr),
          _args: args(_expr),
          /* add the operators to the opList */
          _newList: cons(_op, _opList),
          for _arg in _args do _newList: listGDFPriv(_arg,_y,_x, _newList),
          _newList
        )
)$



/* c^f(x,y)  or f(x,y)^c  or sqrt(f(x,y))*/
gdfGeneral1(_f,_y,_x):=(op(_f)="^" and (
                         ((atom(args(_f)[1]) and freeof(_x,_y,args(_f)[1])) and not(freeof(_x,args(_f)[2])) and not(freeof(_y,args(_f)[2])) ) 
                         or 
                         ((atom(args(_f)[2]) and freeof(_x,_y,args(_f)[2])) and not(freeof(_x,args(_f)[1])) and not(freeof(_y,args(_f)[1])) )
                         )) 
                      or (op(_f)=sqrt and not(freeof(_x,args(_f)[1])) and not(freeof(_y,args(_f)[1])) )
$

/* ************************************************************************* */
/* ***** print expr only when flag<DEBUGFLAG                           ***** */
/* ************************************************************************* */
dprint(flag,[_expr])::= if flag <= DEBUGFLAG then buildq ([_expr], print (splice (_expr)))$
/* ************************************************************************* */


/* ************************************************************************** */
/* we introduce dependencies and gradefs for the ode                          */
/* ************************************************************************** */
explicit_form_to_dependencies_form1(_ode) :=block([_udfargs], 
/* ************************************************************************** */
  /* get a list of user defined functions */
  _dependencylist : copy(dependencies),
 
  _listudf : listUDF(rhs(_ode)),
  _listudf : sublist(_listudf,lambda([_i], not(length(args(_i))=1 and atom(args(_i)[1])))),
  _udf_op : map(op,_listudf),
  _udf_args : flatten(map(args,_listudf)), 

  /* get a list of generally defined functions */ 
  _listgdf : listUDFGeneral(rhs(_ode)),
  _listgdf : sublist(_listgdf,lambda([_i], not(length(args(_i))=1 and atom(args(_i)[1])))),
  _listgdf : append(_listgdf,listGDF(rhs(_ode),_y,_x)),
  /* remove everything that is already in listudf */
  _listgdf : unique(sublist(_listgdf,lambda([_i],not(member(_i,_listudf))))),
  _gdf_op : map(op,_listgdf),
  _gdf_args : unique(flatten(map(args,_listgdf))),

  /* for the udf, we need to introduce new variables      */
  /* note that we remove gradefs by removing dependencies */
  _varlist:makelist(concat(%g,_i),_i,1,length(_udf_args)),
  dprint(5,"varlist = ",_varlist), 
   depends(_varlist,[x,y]),
   _udfargs : _udf_args,  
   for _g in _varlist do (
      apply('gradef,[_g,_x,diff(first(_udfargs),_x)]),   
      apply('gradef,[_g,_y,diff(first(_udfargs),_y)]),
      _udfargs:rest(_udfargs)    
   ), 

  /* replace all udfs with their operators: f(ax+by)  -> f */
  _ode : subst(map("=",_listudf,_udf_op),_ode),

  /* only dependencies for the udf, not for the general free functions */
  map(depends,_udf_op,_varlist),   

  dprint(5,"canonical form of ode, replaced long arguments = ",_ode),
  dprint(5,"dependencies=",dependencies),
  dprint(5,"listudf = ",_listudf), 
  dprint(5,"udf_op = ",_udf_op), 
  dprint(5,"udf_args = ",_udf_args), 
  dprint(5,"listgdf = ",_listgdf), 
  dprint(5,"gdf_op = ",_gdf_op), 
  dprint(5,"gdf_args = ",_gdf_args), 
  /* ***** ************************************************* ***** */
  return(_ode)
)$
/* ************************************************************************** */


