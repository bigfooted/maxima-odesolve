/* ************************************************************************** */
/* *****     ode2_lie                                                   ***** */
/* *****                                                                ***** */
/* *****     Author: Nijso Beishuizen                                   ***** */
/* *****                                                                ***** */
/* ***** Description: routines to solve first order ode's               ***** */
/* ***** Based on the paper by Cheb-terrab and Kolokolnikov             ***** */
/* ***** First-Order ordinary differential equations, symmetries and    ***** */
/* ***** linear transformations, European Journal of Applied Mathematics***** */ 
/* ***** 14 (2003) pp. 231-246                                          ***** */
/* ***** Cheb-terrab, Duarte, da Mota, Computer algebra solving of      ***** */
/* ***** first order odes using symmetry methods                        ***** */                                
/* ***** Computer Physics Communications                                ***** */
/* ***** Cheb-Terrab and Roche - Symmetries and first order ODE         ***** */
/* ***** patterns, Computer Physics Communications 113 (1998)           ***** */                                      
/* ***** F. Schwarz - Abel ode paper                                    ***** */ 
/* ************************************************************************** */

/*
construct most general ode with symmetry
construct integrating factor with symmetry
transform ode using transformation
transform symmetry using transformation

todo: this should work: depends(u,x)
*/

/* ************************************************************************** */

batch("/home/nijso/mathematics/maxima_files/separable.mac");
batch("/home/nijso/mathematics/maxima_files/ode1_abel.mac");
/* ************************************************************************** */
put('ode1_Lie,001,'version)$
/* ************************************************************************** */

/* ***** ode solver method used ***** */
method : "none"$

/* ***** print all statements with flag lower than DEBUGFLAG           ***** */
DEBUGFLAG:5$
/* RULES for printing messages */
/* DEBUGFLAG=0 : fatal errors */
/* DEBUGFLAG=1 : warnings */
/* DEBUGFLAG=2 : main routine */
/* DEBUGFLAG=3 : additional intermediate results */
/* DEBUGFLAG=4 : intermediate evaluation outputs */
/* DEBUGFLAG=5 : intermediate evaluation outputs, least important, lot's of output */

/* use a fixed value for the constant of integration, which is integration_constant (usually %c) */
FIX_INTEGRATION_CONSTANT:true$
/* return symmetries as part of the solution*/
returnSymmetries:true$
/* return integrating factor as part of the solution*/
returnIntegratingFactor:true$
/* return the solution */
returnSolution:true$
/* return the solution in explicit form */
returnExplicit:true$

halfangles   : true$                              /* if true, converts trigonometric halfangles, i.e. tan(x/2), sin(x/2), etc    */

/* this is useful for the pfaffian form of the ode */
%edispflag   : true$                              /* if true, writes negative powers of %e as a quotient, i.e. %e^-x  ->  1/%e^x */
exptdispflag : true$                              /* if true, writes exponents with negative powers as quotients                 */

linsolvewarn:false$                               /* suppresses warning messages from linsolve (dependent equations eliminated) */

/*
Diff(_f,_x):=block([indepvar:args(_f)[1],depvar:op(_f)],
  print("indepvar =",indepvar),
  print("depvar=",depvar),
  print("diff=",diff(_f,_x)*diff(indepvar,_x)),
  return(diff(_f,_x)*diff(indepvar,_x))
)$
*/

/* freeof, including dependencies */
free_of(_x,_expr):=(block[_substlist],
    _substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_expr),

    return(freeof(_x,_expr))
)$

/* we can have y= ax + b, with a and b zero */
matchdeclare (_la, freeof(_x), _lb, freeof(_x))$
defmatch (linearp, _la*_x + _lb, _x)$

/* Riccati equation*/
matchdeclare (_f2, lambda ([_e], _e#0 and freeof(_y, _e)), _f1, freeof(_y),_f0,freeof(_y))$
defmatch (riccatip, _f2*_y^2 + _f1*_y+_f0, _y)$

/* checks if an expression is of the form f(x) + g(y) */
matchdeclare (_fx, lambda ([_f], _f#0 and freeof(_y, _f)), _gy, lambda([_g],_g#0 and freeof(_x,_g)),_h,freeof(_x,_y) )$
defmatch(fxplusgyplush,_fx + _gy + _h,_x,_y)$

/* find a and b in the expression a(x) + b(x,y) */
matchdeclare(_A,freeof(_y),_B,lambda([_e], _e#0 and not(freeof(_y,_e))));
defmatch (AplusBF, _A + _B, _x,_y);

/* detect p1*sqrt(p2/q2) and split into sqrt(p2) and sqrt(q2) */
matchdeclare(_p1,lambda([_e1],_e1#0),_p2,lambda([_e3],_e3#0),_q2,lambda([_e4],_e4#1));
defmatch(sqrtOfFraction,_p1*sqrt(_p2/_q2));


/* ************************************************************************** */
/* ***** MAIN ROUTINE                                                   ***** */
/* ***** solves a first order ode by trying to find point symmetries    ***** */ 
/* ************************************************************************** */
ode1Solve(_ode,_y,_x,[options]) := block(
[_xi:false, _eta:false,_mu,_P,_Q,dependencies_changed,_exactode,
 dc,dependencies_copy,d,d1,d2,symmetriesfound:false,ReasonFailure:"failed",_freefunctions:[],_dependencylist:dependencies,_solution:[],_undet_var,_undet_xi,_undet_eta,_returnExplicit,_returnSymmetries,_returnIntegratingFactor,_returnSolution],

  _returnSymmetries       : assoc('returnSymmetries,options,returnSymmetries),               /* if true, compute symmetries X and return [X]=[[xi,eta]] */
  _returnIntegratingFactor: assoc('returnIntegratingFactor,options,returnIntegratingFactor), /* if true, compute X and integrating factor mu, return [[mu]] */
  _returnSolution         : assoc('returnSolution,options,returnSolution),                   /* if true, compute X, mu and solution and return [solution] */
  _returnExplicit         : assoc('returnExplicit,options,returnExplicit),                   /* if true, then try to write solution in explicit form */
  useCanonical           : assoc('useCanonical,options,true),                               /* if true, the ode will be converted into canonical form using several simplification methods. */
  tryInverse             : assoc('tryInverse,options,true),                                 /* if true, try to find symmetries of the inverse-ode when no symmetries could be found for the ode */
  useMethod              : assoc('useMethod,options,"all"),                                 /* choose a specific method for the solver */

  /* for the method of undetermined coefficients */
  _undet_var             : assoc('varlist,options, [__a1,__a2,__a3,__a4,__a5,__a6,__a7,__a8,__a9,__a10,__b1,__b2,__b3,__b4,__b5,__b6,__b7,__b8,__b9,__b10]),                
  _undet_xi              : assoc('xi,options, __a1*_x + __a2*_y + __a3 + __a4*_x^2 + __a5*_y^2 + __a6*_x*_y + __a7*_x^3 + __a8*_x*_y^2 + __a9*_x^2*_y + __a10*_y^3),                
  _undet_eta             : assoc('eta,options, __b1*_x + __b2*_y + __b3 + __b4*_x^2 + __b5*_y^2 + __b6*_x*_y + __b7*_x^3 + __b8*_x*_y^2 + __b9*_x^2*_y + __b10*_y^3),                
  

  dprint(5,"---------- return symmetries?              = ",_returnSymmetries),
  dprint(5,"---------- return integrating factor?      = ",_returnIntegratingFactor),
  dprint(5,"---------- return solution?                = ",_returnSolution),
  dprint(5,"---------- return explicit solution?       = ",_returnExplicit),
  dprint(5,"---------- using method                    = ",useMethod),
  dprint(5,"---------- use canonical form              = ",useCanonical),
  dprint(5,"---------- try inverse linear?             = ",tryInverse),

  dprint(5,"start::dependencies=",dependencies),

  /* set the global solution method */
  method:"none",

  /* 
  TODO: give useMethod as an ordered list, e.g. useMethod=["linear","separable"]
  */

  /* 1. check input */
  /* check if input is a first order ode */
  type: odeType(_ode,_y,_x,'firstorder),
  dprint(5,"type = ",type),
  if type=false then (
    dprint(0,"error: input is not a valid first order ordinary differential equation"),
    return([false,"invalid ode"])
  ),

  /* if ode is of type implicit then we enter here... */
  if type[1]="implicit first order ode" then (
    dprint(0,"error: implicit ODE, not implemented yet, use sym_implicit!"),
    return([false,"implicit ode"])
  ),

  /* rewrite the ode to canonical form */
  dprint(5,"ode = ",_ode),
  if useCanonical=true then _odeCanonical: ode1CanonicalForm(_ode,_y,_x),
  dprint(5,"canonical form of ode = ",_odeCanonical),
 
  /* inverse-ode: search for inverse-symmetries */
  if (tryInverse=true) then (
    _inv_ode : 'diff(_y,_x) = simplify(1/(sublis([_x=_y,_y=_x],rhs(_odeCanonical)))),
    if useCanonical=true then _inv_ode : ode1CanonicalForm(_inv_ode,_y,_x),
    dprint(5,"canonical form of inverse-ode = ",_inv_ode) 
  ),
 
  _ode_depform : explicit_form_to_dependencies_form(_odeCanonical),
  dprint(5,"listudf = ",_listudf), 
  dprint(5,"udf_op = ",_udf_op), 
  dprint(5,"udf_args = ",_udf_args), 
  dprint(5,"listgdf = ",_listgdf), 
  dprint(5,"gdf_op = ",_gdf_op), 
  dprint(5,"gdf_args = ",_gdf_args), 
  dprint(5,"dependencies=",dependencies),

 
  /* write as pfaffian ode:  dy/dx = Q/P -> Pdy - Qdx = 0 */
  [_P,_Q] : ode1PfaffianForm(_ode_depform,_y,_x),
  dprint(5,"P = ",_P), 
  dprint(5,"Q = ",_Q),


  /* ***************************************************** */
  /* ***** searching for symmetries                  ***** */
  /* ***************************************************** */
  dprint(4,"Checking if ODE has simple symmetries..."),
  _X : findSymmetries(_Q,_P,_y,_x,'useMethod=useMethod,'varlist=_undet_var,'xi=_undet_xi,'eta=_undet_eta),
  if (_X[1] # false) then (
    dprint(4,"simple symmetries found"),
    [_xi,_eta] : _X,
    symmetriesfound : true,
    dprint(4,"[xi,eta]=[",_xi,",",_eta,"]")
  )
 
  /* search for inverse-symmetries if we could not find a symmetry */
  else if _X[1]=false and tryInverse=true then (

    /* we have to recompute the dependencies */
    kill(dependencies),
    if _dependencylist#[] then map(depends, map(op,_dependencylist), map(args,_dependencylist)),
    _inv_ode : explicit_form_to_dependencies_form(_inv_ode),

    dprint(2,"** trying inverse ode ** "),
    [_inv_P,_inv_Q] : ode1PfaffianForm(_inv_ode,_y,_x),
    _X : findSymmetries(_inv_Q,_inv_P,_y,_x,'useMethod=useMethod,'varlist=_undet_var,'xi=_undet_xi,'eta=_undet_eta),
    if (_X[1] # false) then (
      dprint(4,"simple symmetries found"),
      [_eta,_xi] : sublis([_x=_y,_y=_x],_X),
      symmetriesfound : true,
      method : concat("inverse-",method),
      dprint(4,"[xi,eta]=[",_xi,",",_eta,"]")
    )
  )
  else (
    dprint(4,"no simple symmetries found"),
    /* if the reason it failed was Riccati or Abel, then we cannot solve them currently */
    /* moreover, the (useless) search for linear symmetries might take a very long time */
    ReasonFailure : _X[2]
    /*if (ReasonFailure = "Riccati") or (ReasonFailure="Abel") then return(ReasonFailure)*/
  ),


  if (symmetriesfound=true) then (

    dprint(4," symmetries were found!"),
    dprint(4,"[xi,eta]=[",_xi,",",_eta,"]"),
    _X : simplify([_xi,_eta]),
    dprint(4,"simplified [xi,eta]=[",_xi,",",_eta,"]"),

    dprint(4,"checking if it is truly a symmetry:"),
    isit : checkSymmetries([_xi,_eta],_ode_depform,_y,_x),
    dprint(4,"end checking if it is truly a symmetry:",isit),
    dprint(4,"returnsymmetries=",_returnSymmetries), 
    /* ***** Add the symmetries to the result list ***** */
    if (_returnSymmetries=true) then(
      dprint(4,"returning symmetries..."),
      _solution:endcons(_X,_solution)
    ),
    /* ***** compute the integrating factor ***** */
    if (_returnIntegratingFactor=true) or (_returnSolution=true) then ( 
      dprint(4,"returning integrating factor..."),
      _mu : ODE1_IntegratingFactor(_Q,_P,_xi,_eta),
      if (_returnIntegratingFactor=true) then 
        _solution:endcons([_mu],_solution), 

      if _mu=false then (
        dprint(0,"error: trivial symmetries used for constructing integrating factor")
        /*return([false,"trivial symmetries:",_xi,_eta])*/
      ),
      dprint(4,"integrating factor = ",_mu),
      dprint(4,"integrating factor = ",grind(_mu)),
      dprint(4,"checking if it is truly an integrating factor:"),
      _exactode : diff(_mu*_P,_x) + diff(_mu*_Q,_y), /* extra ratsimp for 1.350 (?)*/
      _exactode : simplify(_exactode), 
      dprint(4,"1. Does integrating factor make ODE exact?  ",grind(_exactode), " ",is(_exactode=0))
    ),

    if (_returnSolution=true) then ( 
      /* ***** only return the solution ***** */
      _sol: ODE1_SolveWithIntegratingFactor(_Q,_P,_mu,_y,_x,_returnExplicit),
      _solution : endcons(_sol,_solution)
/*
      dprint(4,"returning solution..."),
      if _mu=false then (
        dprint(0,"error: trivial symmetries used for constructing integrating factor"),
        return([false,"trivial symmetries"])
      ),
      dprint(4,"integrating factor = ",_mu),
      dprint(4,"integrating factor = ",grind(_mu)),
      dprint(4,"checking if it is truly an integrating factor:"),
      _exactode : diff(_mu*_P,_x) + diff(_mu*_Q,_y), /* extra ratsimp for 1.350*/
      _exactode : simplify(_exactode), 
      dprint(4,"Does integrating factor make ODE exact?  ",grind(_exactode), " ",is(_exactode=0)),

*/
    )
  ), 


   kill(dependencies),
   if _dependencylist#[] then map(depends, map(op,_dependencylist), map(args,_dependencylist)),
  
  return(_solution)
)$
/* -------------------------------------------------------------- */


/* ************************************************************************** */
/* check for linear symmetries: algorithm of Cheb-terrab and Kolokolnikov */
/* ************************************************************************** */
linearSymmetries(_odeCanonical,_y,_x):=block(
[_ode,_phi,_phi_y,_phi_yy,_phi_yyy,_A,_A_x,_A_y,_A_yy,_A_yx,_At,_ytrans,_transf,_inv_transf,_I,_I_y,_p,_odenew,_X,_eta,_xi,_u,_t],

  dprint(4,"   trying [xi,eta]=[F(x), P(x)*y+Q(x)]"),  
  dprint(4,"odecanonical=",_odeCanonical),
  /* after the coordinate transformation, write in dependencies-form */
  _ode : explicit_form_to_dependencies_form(_odeCanonical),
  dprint(4,"ode=",_ode),

  /* 2. equation (2.9) */
  _phi    : rhs(_ode),
  _phi_y  : simplify(diff(_phi,_y)), 
  _phi_yy : simplify(diff(_phi_y,_y)),
  _phi_yyy: simplify(diff(_phi_yy,_y)),

  if (_phi_yyy = 0) then (
    dprint(4,"most likely a Riccati equation, use another approach!"),
    return(false)
  ),

  _A   : simplify(_phi_yy/_phi_yyy),
  _A_x : simplify(diff(_A,_x)),
  _A_y : simplify(diff(_A,_y)),
  _A_yy: simplify(diff(_A_y,_y)),
  _A_yx: simplify(diff(_A_y,_x)),

  dprint(5,"dependencies=",dependencies),
  kill(dependencies),
  if _dependencylist#[] then map(depends, map(op,_dependencylist), map(args,_dependencylist)),
  dprint(5,"dependencies=",dependencies),

  if _A_y=0 then (
    dprint(4,"case 2.1: A_y = 0"), 
    /* change variables y=A(x)*u */
    depends(_u,_t),
    _At : subst(_x=_t,_A), 
    _ytrans : solve(_u=_At/_y,_y)[1],
    _transf: [_x=_t,_ytrans],
    _inv_transf : [_t=_x,_u=_y/_A]
  ) else if (_A_yy=0) then (
    /* change of variables u  = ln(A)*/
    /* exp(u) = A                    */
    /* A must be linear in y */
    dprint(4,"case 2.2: A_yy = 0, A_y=/=0 "),
    /* temparily let u depend on t */
    depends(_u,_t),
    _At : subst(_x=_t,_A),
    _ytrans : solve(exp(_u)=_At,_y)[1],
    dprint(5,"At=",_At), 
    dprint(5,"yt=",_ytrans), 
    _transf: [_x=_t,_ytrans],
    _inv_transf:[_t=_x,_u=log(_A)], 
    dprint(5,"transf=",_transf)
  ) else (
    dprint(4,"general case, A_yy != 0"), 
    /* y=u/p, p=exp(int(I_ydx)), I=A_yx/A_yy*/
    /* dy/dx = d/dx(1/p)*u*/
    dprint(5,"A_yx = ",_A_yx), 
    dprint(5,"A_yy = ",_A_yy), 
    _I : simplify(_A_yx/_A_yy),
    dprint(5,"I = ",_I), 

    /* I must be linear in y, so the second derivative is zero !! */
    if (diff(_I,_y,2) = 0) then 
    (
      dprint(5,"case 4: I linear in y"),
      _I_y : diff(_I,_y),
     
      /* substitute all dependencies for integration       */ 
      /* note that we have already stored the dependencies */
      _p : integrate(_I_y,_x),
      /* substitute back to dependencies form */
      _p : radcan(exp(_p)),
      dprint(5,"p = ",_p),
      /*_p_x : diff(_p,_x),*/

      depends(_u,_t),
      _A : 1/_p,
      _At : subst(_x=_t,_A),
      _ytrans : _y=_At*_u,
      dprint(5,"At=",_At), 
      dprint(5,"yt=",_ytrans), 
      _transf: [_x=_t,_ytrans],
      _inv_transf:[_t=_x,_u=_y/_A],
      dprint(5,"transf=",_transf) 
    )
    else 
    (
      depends(_u,_t),
      _ytrans : _y=_u,
      _transf : [_x=_t,_y=_u], 
      _inv_transf:[_t=_x,_u=_y],
      dprint(2,"I is not linear in y. Just trying without transformation ")
    )    
  ),

  /* check the symmetry for the transformed ode */
  _odenew: subst(_transf,_odeCanonical),         
  _odenew : ev(_odenew,nouns),
  _odenew : solve(_odenew,diff(_u,_t))[1],
  _odenew : simplify(_odenew),
  /* after the coordinate transformation, write in dependencies-form */
  _odenew : explicit_form_to_dependencies_form(_odenew),
  /* symmetry3 is the search for symmetries of the form [xi,eta]=[F(x),Q(x)] */
  remove(_u,dependency),
  _X : ode1_SimpleSymmetries(rhs(_odenew),_u,_t,'useMethod="symmetry3"),
  dprint(5,"X = ",_X),

  if _X=false then return(false),

  /* the symmetry was ok, now compute the symmetry for the original ode */

  /* now change back and find the symmetries of the original ode */
  /* X(u,v) = (X(x,y)*u)*du[.] + (X(x,y)*v)*dv[.] + */
  /* with X(x,y) = xi*dx[.] + eta*dy[.] */
  [_xi,_eta] : [_X[1]*diff(_t,_t) + _X[2]*diff(_t,_u), _X[1]*diff(rhs(_ytrans),_t) + _X[2]*diff(rhs(_ytrans),_u)],
  [_xi,_eta] : ev([_xi,_eta],nouns),
  [_xi,_eta] : subst(_inv_transf,[_xi,_eta]),
  [_xi,_eta] : simplify([_xi,_eta]),   
 
  /* once we get here, we were successfull. We return the symmetries */ 
  return([_xi,_eta])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* Determine integrating factor mu of first order ode y'=phi(x,y) */
/* given symmetry generators [ xi(x,y), eta(x,y) ]                */
/* mu = 1/(eta - xi*phi)                                          */
/* ************************************************************************** */
ODE1_IntegratingFactor(_Q,_P,xi,eta) := block([_denom,_mu],
/* -------------------------------------------------------------- */
  _denom : simplify(_xi*_Q-_eta*_P),
  dprint(4,"denom = ",_denom), 
  
  if (_denom=0) then return(false) else (
    _mu:1/_denom,
    dprint(4,"mu = ",_mu), 
    mu: simplify(_mu),
    dprint(4,"simplified mu = ",_mu), 

    /* change sign if mu is negative, they are both integrating factors */
    if signum(_mu)=-1 then _mu:-_mu,

    return(_mu)
  )
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* Solve the first order ode y'=phi(y,x) when the integration     */
/* factor is known                                                */
/* when we have the integration factor mu of the first order ODE  */
/* we can integrate the ode                                       */
/* int(mu*dy) - int(mu*phi*dx))                                   */
/* Note that this is a partial integration, where in the integral */
/* all variables over which the integration does not take place   */
/* are considered constant                                        */
/* Step 1: integrate(mu*dy)+f(x)   -> take the derivative with    */
/* respect to x:  d/dx(integrate(mu*dy)) + f'(x)                  */
/* then substitute this into the second integration               */
/* f'(x) = -integrate(mu*dy)                                      */
/* ************************************************************************** */
newODE1_SolveWithIntegratingFactor(_Q,_P,_mu,_y,_x,_returnExplicit) := block(
/* ************************************************************************** */
  [_I,_C,_f,sol_explicit,_A,_B,_X,linearconstants],

/*_Q : -_Q,*/

/* e.g. Stephani, Differential equations */
/* this is the first integral, the solution in implicit form */
/*_I : integrate(_mu,_y) - integrate(_mu*_phi,_x),*/

/* take integration constant counter into account */
if FIX_INTEGRATION_CONSTANT=true then
  _C : integration_constant
else ( 
  _C : concat(integration_constant,integration_constant_counter),
  integration_constant_counter:integration_constant_counter+1
),

_I : simplify(integrate(-_mu*_Q,_x)), /* + f(y) */
dprint(5,"first integral = ",_I),
_f : simplify(integrate(_mu*_P - diff(_I,_y),_y)),
dprint(5,"f = ",_f),
 _I : simplify(_I + _f)=_C,
dprint(5,"first integral = ",_I),

  if (_returnExplicit=false) then (
    dprint(5,"implicit solution"),
    sol : [_I]
  )
  else (
    dprint(5,"explicit solution"),
    if not freeof(integrate,_I) then (
      declare(integrate,linear),
      sol_explicit:solve(_I,_y),
      remove(integrate,linear)
    )
    else sol_explicit : solve(_I,_y),

    sol_explicit : simplify(sol_explicit),
    dprint(5,"explicit solution =",sol_explicit ),
    if sol_explicit=[] then (
      dprint(1,"warning: explicit solution was requested but could not write solution in explicit form")
    ) else sol:sol_explicit
  ),
  dprint (5,"solution = ",sol),
  dprint (5,"_y = ",_y),
  dprint (5,"solution = ",lhs(sol[1])),
  dprint (5,"solution = ",is(lhs(sol[1])=_y) ),


  /* simplify some constants in the solution */
  /* only do this when the solution is explicit */
  if is(lhs(sol[1])=_y) then (
    linearconstants:linearp(ratexpand(rhs(sol[1])),integration_constant),
    dprint(4,"linearconstants=",sol[1]),
    dprint(4,"linearconstants=",linearconstants),

    if linearconstants#false then (
     _A:rhs(linearconstants[1]),
     _B:rhs(linearconstants[2]),
     _X:rhs(linearconstants[3]),
     dprint(4,_A,", ",_B,", ",_X),
     if not atom(_B) and (op(_B)="-") then _B: - _B, /* if we have y=f(x) -B(x)*%c then change to y=f(x)+B(x)*%c */
     if (_B#0) and (freeof(_x,_B)) then _B:1,        /* if we have y=f(x) +B*%c with B a constant, change to y=f(x) + %c */ 
     sol: [_y = _A + _B*_X] 
    )  
  ),

  /* simplify e^(x+%c) into %c*e^x */
  sol : simpConstInExp(sol,_y,_x),


  dprint (5,"solution = ",sol),


  return(sol)
)$
/* ************************************************************************** */
/* ************************************************************************** */
/* we have a solution to the ODE,                                             */
/* simplify it and also try to create a clean integration constant            */
/* ************************************************************************** */
cleanupODESolution(expr,_y,_x,_returnExplicit):=block([res1:[],expr1,realexpr:false,expressionBecameComplex:false,logmin1:false,linearconstants,_A,_B,_X],
  dprint(5,"clean up ",grind(expr)),
  /* first, evaluate all unevaluated noun forms */
  expr: ev(expr,nouns),
  expr:simplify(expr),
  dprint(5,expr),
  
  if freeof(%i,expr) then realexpr:true,
  dprint(5,"is expression real: ",realexpr),

  /* simplify some logarithms */
  if not(freeof(log,expr)) then (
    expr1:logcontract(radcan(expr)), 
    if (realexpr=true) and not(freeof(%i,expr1)) then expressionBecameComplex:true,
    if not(freeof(log(-1),expr1)) then logmin1:true,
    if expressionBecameComplex=false and logmin1=false then expr:expr1
  ),
  dprint(5,"2: ",expr),

  /* simplify some complex expressions */
  /*if not(freeof(%i,expr)) and (convertImaginary=true) then expr: rectform(expr), */ /* to convert for instance (-1)^%i */
  if not(freeof(%i,expr)) then expr: rectform(expr), /* to convert for instance (-1)^%i */
  dprint(5,"3: ",expr),

  if _returnExplicit=true then (
      /* then, try to solve explicitly in terms of the dependent variable. If the solution contains integrals, */
      if not freeof(integrate,expr) then (
        declare(integrate,linear),
        expr1:solve(expr,_y),
    dprint(5,"44. explicit solution =",expr1 ),
        remove(integrate,linear)
      ) else expr1:solve(expr,_y),

    dprint(5,"4. explicit solution =",expr1 ),
    expr1 : simplify(expr1),
  
    dprint(5,"5. explicit solution =",expr1 ),
    if expr1=[] then (
      dprint(1,"warning: explicit solution was requested but could not write solution in explicit form")
    ) else expr:expr1
  
    /* sometimes we introduce imaginary numbers in the explicit result. we dont want that in general. */
/*
    if (realexpr=true) and freeof(%i,expr1) then ( 
      if expr1 # [] and freeof(_y,rhs(expr1)) then expr:expr1 /* else expr:[expr=0]*/
    )
*/
  
  ),


  dprint(5,"4 : ",expr),
  expr:ev(expr,nouns),
  dprint(5,"4 : ",ratexpand(rhs(expr[1]))),

  if(lhs(expr[1])=_y) then (
    linearconstants:linearp(ratexpand(rhs(expr[1])),integration_constant),
     dprint(4,"linearconstants=",linearconstants),
   
    if linearconstants#false then (
     _A:rhs(linearconstants[1]),
     _B:rhs(linearconstants[2]),
     _X:rhs(linearconstants[3]),
     dprint(4,"_A=",_A),
     dprint(4,"_B=",_B),
     dprint(4,"_X=",_X),
     /*if not atom(_B) then and (op(_B)="-") then _B: - _B,*/ /* if we have y=f(x) -B(x)*%c then change to y=f(x)+B(x)*%c */
     if signum(_B)=-1 then _B: - _B, /* if we have y=f(x) -B(x)*%c then change to y=f(x)+B(x)*%c */
     if (_B#0) and (freeof(_x,_y,_B)) then _B:1,        /* if we have y=f(x) +B*%c with B a constant, change to y=f(x) + %c */ 
     expr: [_y = _A + _B*_X ]
    )  
  ),
  /* for some reason we need to do ev,nouns  again */ 
  dprint(5,"6 : ",expr),
  expr:ev(expr,nouns),
  dprint(5,"6 : ",expr),
  expr:simpConstInExp(expr,_y,_x),
  /*res:MakeConstPos(res),*/

  return(expr)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* *****  solve an ode using an integrating factor and simplify result  ***** */
/* ************************************************************************** */
ODE1_SolveWithIntegratingFactor(_Q,_P,_mu,_y,_x,_returnExplicit):=block([_check,_res,mu_P,mu_Q,exactode,_N,_M,res1,res2,sol],

  /* --- check all the optional arguments --- */
  /*_mu		   : assoc('integratingFactor,options,[]),                */

  dprint(4,""),
  dprint(4,"---------- optional arguments : -----------------------------"),
  dprint(4,"---------- use integrating factor        = ",_mu),
  dprint(4,""),
/*
  if _mu=false then (
    dprint(0,"only integrating factor is implemented!"),
    return(false)
  ),
*/


/* take integration constant counter into account */
if FIX_INTEGRATION_CONSTANT=true then
  _C : integration_constant
else ( 
  _C : concat(integration_constant,integration_constant_counter),
  integration_constant_counter:integration_constant_counter+1
),

  _P : rootscontract(_P),_Q:rootscontract(_Q), /* the simplification to canonical could introduce imaginary numbers when square roots are in the expression */

  dprint(4,"P = ",grind(_P)), 
  dprint(4,"Q = ",grind(_Q)),

  _mu: ratsimp(trigsimp(_mu)),
  /* rootscontract converts products of roots into roots of products, simplifies an expression like 1/(sqrt(x-%i)sqrt(x+%i)) = 1/(sqrt(x^2+1)) */
  /* note that abs(x) can also be put into the root when x is real*/
  _mu: rootscontract(_mu),
  dprint(4,"MU = ",grind(_mu)),

  /* we try to get rid of imaginary numbers */
  mu_P : num(_mu),
  mu_Q : denom(_mu),
  /*if not freeof(%i,mu_P) and (convertImaginary=true) then (*/
  if not freeof(%i,mu_P) then (
    mu_P : rootscontract(mu_P),
    mu_P : rectform(radcan(mu_P)), /* for simplification of e.g. -1^%i*/
    mu_P : trigreduce(trigsimp(demoivre(mu_P))) /* if mu=exp(sin(x)) then exponentialize(mu) has exploded this expression and introduced complex numbers */
  ),
  /*if not freeof(%i,mu_Q) and (convertImaginary=true) then (*/
  if not freeof(%i,mu_Q) then (
    mu_Q : rootscontract(mu_Q),
    mu_Q : rectform(radcan(mu_Q)), /* for simplification of e.g. -1^%i*/
    mu_Q : trigreduce(trigsimp(demoivre(mu_Q))) /* if mu=exp(sin(x)) then exponentialize(mu) has exploded this expression and introduced complex numbers */
   
  ),
  dprint(4,"MU = ",mu_P,"/ ",mu_Q),

  _mu : radcan(mu_P / mu_Q),

/*
    if not freeof(%e,_mu) then 
      _mu: radcan(exponentialize(_mu)), /* will simplify e.g. exp(log(a*x+b)) */
*/

  dprint(4,"MU = ",grind(_mu),_y,_x),

  exactode : radcan(trigsimp( ratsimp(diff(_mu*_P,_x) + diff(_mu*_Q,_y)))), /* extra ratsimp for 1.350*/
/*  dprint(1,"Does integrating factor make ODE exact?  ",grind(exactode), " ",is(exactode=0)),*/
  

  /* we integrate the exact equation. note that we can do that in two ways and we need to choose the easiest one */
  /* NB: trigsimp helps in simplifying e.g. kamke1.6, speedup from 20s to 1s !!! */
  _N : trigsimp(ratsimp(-_mu*_P)),
  _M : trigsimp(ratsimp(_mu*_Q)),
  dprint(4,"N = ",grind(_N)),
  dprint(4,"M = ",grind(_M)),


/* *************************** */
  halfangles : false,
/* *************************** */
  res1: integrate(_M,_x),
  dprint(4,"res1 = ",grind(res1)),

  /* is this really necessary? */
  /*if freeof(%i,res1) then (*/
    res1: radcan(res1),                          /* kamke 364*/
  /*  if freeof(%i,res1a) then res1:res1a*/
  /*),*/
  dprint(4,"res1 = ",grind(res1)),

  res2: integrate(_N,_y),
  dprint(4,"res2 = ",grind(res2)),

  /*if freeof(%i,res2) then (*/
    res2: radcan(res2),
  /*  if freeof(%i,res2a) then res2:res2a*/
  /*),*/


  res3: diff(res1,_y),     
  dprint(4,"res3 = ",grind(res3)),
  
  /* radcan: simplifies kamke1.41, we should only use radcan when we do not have %i terms (messes up results) */
  /*if freeof(%i,res3) then (*/
    res3: radcan(res3),
  /*  if freeof(%i,res3a) then res3:res3a*/
  /*),*/

  res3: integrate(res3,_y),
  sol: res1 + res2 - res3 = _C,
/*
  dprint(4,"sol = ",sol), 
  sol : ratsimp(sol),
  dprint(4,"(ratsimp)sol = ",sol), 
  if trigonometricp(sol) then (
    sol : trigexpand(sol),  
    dprint(4,"(trigexpand)sol = ",sol), 
    sol : trigsimp(sol),    
    dprint(4,"(trigsimp)sol = ",sol), 
    sol : trigreduce(sol),
    dprint(4,"(trigreduce)sol = ",sol) 
  ),
*/
/* *************************** */
   halfangles : true,
/* *************************** */

  /* clean up and try to write in explicit form*/
    sol: cleanupODESolution(sol,_y,_x,_returnExplicit),

  return(sol)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* simplify constant appearing in exponential term                            */
/* e.g. y = f(x) + exp(%c)  ==>  y = f(x) + %c                                */
/* ************************************************************************** */ 
simpConstInExp(expr,depvar,indepvar):=block([_Expterms,_coef:0,_newExpr,_subst],
  /* temporary substitution */
  /*subst(%c%,%c,expr),*/

  dprint(4,"simplify constant: expr = ",expr),
  dprint(4,"simplify constant: depvar = ",depvar),
  dprint(4,"simplify constant: indepvar = ",indepvar),

  _newExpr:expr,
  _Expterms: allTerms(expr),
  dprint(4,"exprterms = ",_Expterms),

  if length(_Expterms)>0 then  
    for i:1 thru length(_Expterms) do   
      if not(freeof(depvar,_Expterms[i][1])) or not(freeof(indepvar,_Expterms[i][1])) then _subst:false,

  if length(_Expterms)>1 then   
    for i:2 thru length(_Expterms) do   
      if _Expterms[i-1][1]#_Expterms[i][1] then _subst:false,

  if _subst=false then return(expr),

  for arg in _Expterms do 
    _newExpr:subst(integration_constant*exp(arg[2]),exp(arg[1]*integration_constant+arg[2]),_newExpr),

  /* this happens when there were other %c terms in the expression that are not inside exp(), like %c*exp(a*%c+b) */
  /*if not freeof(%c%,_newExpr) then return(expr),*/

  return(_newExpr)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ************************************************************************** */
/*
MakeConstPos(expr):=block([newexpr],
  newexpr: ratsimp(((rhs(expr)-lhs(expr)+integration_constant))),
  if freeof(integration_constant,newexpr) then return(ratsimp(expr+2*integration_constant))
)$
*/
/* ************************************************************************** */



allTerms(expression):= block( [ ],
  allOpsPriv (expression,[])
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* ************************************************************************** */
allOpsPriv(expression, opList) := block ( [_x, _args, _constcoef,
  _expterm,_newList:opList,_lp],

  if atom(expression) then opList else (
    _x: op(expression),
    _args: args(expression),
    if (_args[1] = %e)  and not freeof(%c,_args[2]) then (
      /* only exponential terms containing %c */
      _lp : linearp(_args[2],%c),
      if _lp=false then return(opList), /* capture in case linearp is false */ 
      _constcoef:rhs(_lp[2]),
      _expterm:rhs(_lp[1]),
      /*if freeof(constcoef,depvar) and freeof(constcoef,indepvar) then*/
      _newList: cons([_constcoef,_expterm],opList)
    ),
    for arg in _args do
      _newList: allOpsPriv(arg, _newList),
    _newList
  )

)$
/* ************************************************************************** */


/* ************************************************************************** */
/* this changes dependencies to explicit form                     */
/* the only thing we need to do is to kill the dependencies !!!   */
/* ************************************************************************** */
explicit_form_to_dependencies_form(_ode) :=block( 
  /* get a list of user defined functions */
  /* only at start of the call to odesolve*/
  /*_dependencylist : copy(dependencies),*/
 
  _listudf : listUDF(rhs(_ode)),
  _listudf : sublist(_listudf,lambda([_i], not(length(args(_i))=1 and atom(args(_i)[1])))),
  _udf_op : map(op,_listudf),
  _udf_args : flatten(map(args,_listudf)), 

  /* get a list of generally defined functions */ 
  _listgdf : listUDFGeneral(rhs(_ode)),
  /* remove items from the list that have atom-arguments like sin(x) */
  _listgdf : sublist(_listgdf,lambda([_i], not(length(args(_i))=1 and atom(args(_i)[1])))),
  _listgdf : append(_listgdf,listGDF(rhs(_ode),_y,_x)),
  /* remove everything that is already in listudf */
  _listgdf : unique(sublist(_listgdf,lambda([_i],not(member(_i,_listudf))))),
  _gdf_op : map(op,_listgdf),
  _gdf_args : unique(flatten(map(args,_listgdf))),

  dprint(5,"listudf = ",_listudf), 
  dprint(5,"udf_op = ",_udf_op), 
  dprint(5,"udf_args = ",_udf_args), 
  dprint(5,"listgdf = ",_listgdf), 
  dprint(5,"gdf_op = ",_gdf_op), 
  dprint(5,"gdf_args = ",_gdf_args), 

  /* for the udf, we need to introduce new variables      */
  /* note that we remove gradefs by removing dependencies */
  _varlist:makelist(concat(%g,_i),_i,1,length(_udf_args)),
  dprint(5,"varlist = ",_varlist), 
   depends(_varlist,[x,y]),
   _udfargs : _udf_args,  
   for _g in _varlist do (
      apply('gradef,[_g,_x,diff(first(_udfargs),_x)]),   
      apply('gradef,[_g,_y,diff(first(_udfargs),_y)]),
      _udfargs:rest(_udfargs)    
   ), 


  /* replace all udfs with their operators: f(ax+by)  -> f */
  _ode : subst(map("=",_listudf,_udf_op),_ode),
  dprint(5,"canonical form of ode, replaced long arguments = ",_ode),

  /* only dependencies for the udf, not for the general free functions */
  map(depends,_udf_op,_varlist),   
  dprint(5,"dependencies=",dependencies),

  dprint(5,"d%g1/dx = ",diff(%g1,_x)),
  dprint(5,"d%g1/dy = ",diff(%g1,_y)),


  /* the list of functions that we would like to use for symmetry4 */
  _freefunctions : append(_udf_op, _listgdf),
  dprint(5,"free functions = ",_freefunctions),

   return(_ode) 
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* this changes dependencies to explicit form                     */
/* the only thing we need to do is to kill the dependencies !!!   */
/* and then substitute                                            */
/* ************************************************************************** */
dependencies_form_to_explicit_form(expr) :=block( 
/* ************************************************************************** */
   dc : copy(dependencies),
   kill(dependencies),
   for _i:1 thru length(dc) do (
    expr:subst(dc[_i],op(dc[_i]),expr)
   ),
   [expr,dc]
)$


/* ************************************************************************** */
/* check ode input                                                            */
/* ************************************************************************** */
odeType(_ode,_y,_x,ODEtype):=block([_rhs,_df,_df_x,_df_y,_P,_Q],
  dprint(5,"input ode = ",_ode),
  if freeof('diff,_ode) then (dprint(0,"Error: no differential operator (diff) found!"), return(false)),
  if derivdegree(_ode,_y,_x) # 1 then (dprint(0,"Error: No first order ODE found!"), return (false)), 

  _ode:solve(_ode,'diff(_y,_x)),
 
  if not listp(_ode) then (dprint(0,"Error: could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(["implicit first order ode"])),
  if length(_ode) > 1 then dprint(0,"warning: writing the ODE in the explicit form dy/dx=f(x,y) leads to multiple ODEs: ",_ode),

  _ode : _ode[1],
  if lhs(_ode)#('diff(_y,_x)) then (dprint(0,"Error: could not write ODE explicitly in the form dy/dx = f(x,y) ",_ode), return(["implicit first order ode"])),

  /* we have to check if the ode contains general functions */
/*
  if (heuristics=false) then (
    varlist : showratvars(rhs(_ode)), 
    varlist : sublist(varlist,lambda([_i],not(lfreeof(map(op,dependencies),_i)) or not(lfreeof(dependencies,_i)) or not(freeof('diff,diff(_i,_y))) or not(freeof('diff,diff(_i,_x))))),
    if varlist # [] then (
      dprint(0,"Error: Prelle-Singer method cannot handle general functions."),
      dprint(0,"try again with option 'heuristics=true"),
      return(false)
    )
  ),
*/


  dprint(5,"ODE:",_ode),
  dprint(5,"x (independent variable) : ",_x),
  dprint(5,"y (dependent variable) : ",_y),

  /* dy/dx = M/N =Q/P*/ 
  /*_P:  ratcoeff(_ode,'diff(_y,_x),1),   */
  /*_Q: -ratsimp(_ode - _P*'diff(_y,_x)), */

  return(["explicit first order ode"])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* write ode1 to canonical form:                                              */
/* -write sin,cos,tan,cot, etc as sin,cos                                     */
/* -expand square roots                                                       */
/* ************************************************************************** */
ode1CanonicalForm(_ode,_y,_x):=block([],
  dprint(5,"start canonical form: ode = ",_ode),

  /* try to solve explicitly in the derivative */
  _ode:solve(_ode,'diff(_y,_x)),
  _ode : _ode[1],
  _rhs:simplify(rhs(_ode)),   
  dprint(5,"rhs = ",_rhs), 

  /* splits square roots sqrt(a*b) into sqrt(a)*sqrt(b) and sqrt(a/b) into sqrt(a)/sqrt(b) */
  /*_rhs : rootsexpand(_rhs),*/
  _rhs : radcan(_rhs),
  dprint(5,"rhs = ",_rhs), 
  /* TODO: what about general fractional powers? */
  /* ... */

  /* what about log functions? */
  /* what about sinh functions?*/
  /* etc... */

  return('diff(_y,_x)=_rhs)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* get the pfaffian form of the ode, i.e. if dx/dt=P, dy/dt=Q, then           */
/* dy/dx = Q/P   =>   Pdy = Qdx and we return P,Q                             */
/* ************************************************************************** */
ode1PfaffianForm(_ode,_y,_x):=block([_P,_Q],
  _ode : ratsimp(_ode),
  _Q : num(rhs(_ode)),
  _P : denom(rhs(_ode)),
  return([_P,_Q])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* *****     Check if input mu is an integrating factor of ode          ***** */
/* ************************************************************************** */
isIntegratingFactor(mu,ode,_y,_x) :=(block[_P,_Q,_isIntegratingFactor:false],

  ode: ode1CanonicalForm(ode,y,x),
  /* rewrite the ode to pfaffian form */
  /* Q(x,y)dx - P(x,y)dy = 0 */
  [_P,_Q] : ode1PfaffianForm(ode,_y,_x),
  dprint(4,"P,Q"=_P,_Q),
  /* check if d(mu*P)/dx - d(mu*Q)/dy = 0*/
  dprint(4,"dP/dx=",ratsimp(diff(_P*mu,_x))),
  dprint(4,"dQ/dy=",ratsimp(diff(_Q*mu,_y))),
  dprint(4,"dP/dy=",ratsimp(diff(_P*mu,_y))),
  dprint(4,"dQ/dx=",ratsimp(diff(_Q*mu,_x))),
  
  if (ratsimp(diff(mu*_P,_x) + diff(mu*_Q,_y))=0) then(
    dprint(4,mu, " is an integrating factor of the ode ",ode),
    true
  ) else 
    false
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** check if X is a symmetry of the ode                            ***** */
/* ************************************************************************** */
checkSymmetries(_X,_ode,_y,_x) :=(block[_phi,_xi,_n,_xi_x,_xi_y,_n_x,_n_y,_phi_x,_phi_y,_linearizedSymmetryCondition,_isSymmetry,_substlist,_listudf,_udf_op,_udf_args,_varlist,dependencylist],

  dependencylist : copy(dependencies),  
  dprint(5,"dependencylist = ",dependencylist),

  _ode : solve(_ode,'diff(_y,_x)),
  _phi : ratsimp(rhs(_ode[1])),
  dprint(5,"phi = ",_phi),

  /* ***** ************************************************* ***** */
  /* we need to define derivatives for composite functions/chain rule */
  /* ***** ************************************************* ***** */
  /* get a list of user defined functions */
  if listUDF(_phi)#[] then (
    _listudf : listUDF(_phi),
    dprint(5,"listudf=",_listudf), 
    /* throw away functions depending on only atoms, like f(x) */
    _listudf : sublist(_listudf,lambda([_i], not(length(args(_i))=1 and atom(args(_i)[1])))),
    dprint(5,"listudf=",_listudf),
    /* list f,g,h */
    _udf_op : map(op,_listudf),
    dprint(5,"udf_op=",_udf_op),
    /* list of argumenst*/
    _udf_args : flatten(map(args,_listudf)), 
    dprint(5,"udf_args=",_udf_args),

    /* for the udf, we need to introduce new variables */
    _varlist:makelist(concat(%g,_i),_i,1,length(_udf_args)),
    depends(_varlist,[x,y]),
    for _g in _varlist do (
       print("declaring derivatives for: ",_g),
       print("first of fargs = ",first(_udf_args)),
       apply('gradef,[_g,_x,diff(first(_udf_args),_x)]),   
       apply('gradef,[_g,_y,diff(first(_udf_args),_y)]),
       _udf_args:rest(_udf_args)    
    ), 

    /* only dependencies for the udf, not for the general free functions */
    map(depends,_udf_op,_varlist),   
    dprint(5,"dependencies = ",dependencies),

    /* replace all udfs with their operators: f(ax+by)  -> f */
    _phi : subst(map("=",_listudf,_udf_op),_phi)
    /* ***** ************************************************* ***** */
  ),
  dprint(5,"phi = ",_phi),
  dprint(5,"depvar = ",_y),
  dprint(5,"indepvar = ",_x),
  dprint(5,"X = ",_X),

  /* linearized symmetry condition:                                   */
  /*   n_x + (n_y-xi_x)*phi - xi_y*phi^2 = xi*phi_x + eta*phi_y       */

  _xi : _X[1],
  _n  : _X[2],

  _xi_x  : diff(_xi,_x),
  _xi_y  : diff(_xi,_y),
  _n_x   : diff(_n,_x),
  _n_y   : diff(_n,_y),
  _phi_x : diff(_phi,_x),
  _phi_y : diff(_phi,_y),

  _linearizedSymmetryCondition : _n_x + (_n_y-_xi_x)*_phi - _xi_y*_phi*_phi -_xi*_phi_x - _n*_phi_y,
  dprint(5,"symcond = ",_linearizedSymmetryCondition),
  _linearizedSymmetryCondition : ratexpand(_linearizedSymmetryCondition),
  dprint(5,"symcond = ",_linearizedSymmetryCondition),

/*  _linearizedSymmetryCondition : convert_to_diff(_linearizedSymmetryCondition),*/
  _linearizedSymmetryCondition : ev(_linearizedSymmetryCondition,nouns),
  dprint(5,"symcond = ",_linearizedSymmetryCondition),
  _linearizedSymmetryCondition : simplify(_linearizedSymmetryCondition),
  dprint(5,"symcond = ",_linearizedSymmetryCondition),
 
  /* this is sometimes necessary e.g. for kamke1.70 to completely reduce to 0 */ 
  _linearizedSymmetryCondition : fullratsimp(_linearizedSymmetryCondition),
  dprint(5,"symcond = ",_linearizedSymmetryCondition),
  _isSymmetry : _linearizedSymmetryCondition,
  if (_isSymmetry = 0) then (
    dprint(4,"generator X=", _X , " is a symmetry of ode ",_ode)
  ) else (
    dprint(4,"generator X=", _X , " is NOT a symmetry of ode ",_ode),
    dprint(4,_isSymmetry)
  ),

  if listUDF(ratsimp(rhs(_ode[1])))#[] then (
    kill(dependencies),
    if dependencylist#[] then map(depends, map(op,dependencylist), map(args,dependencylist))
  ),
  _isSymmetry
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** main routine that loops over all symmetry types                ***** */
/* ************************************************************************** */
findSymmetries(_Q,_P,_y,_x,[options]):= block([_xi,_eta,_rhs,linearconstants,_freefunctions_xy,_f,_g,fg,_phi,_phistar,_S,_ode,useMethod,_symfound,_C,_expr,_I,lf,_fx_over_gy,_res,_undet_var,_undet_xi,_undet_eta],
/* ************************************************************************** */
  dprint(5,"findsymmetries::options = ",options), 
  useMethod              : assoc('useMethod,options,"all"),               /* you can set all individual methods: fy,fx,separable,exact,linear,inverse-linear,symmetry1..5, */
  dprint(5,"findsymmetries::method = ",useMethod),                      /* abel, bernoulli, riccati, chini, clairaut, d'Alembert, */
  /* for the method of undetermined coefficients, we need the list of undetermined coefficients, and the undetermined function for [xi,eta]*/
  _undet_var		   : assoc('varlist,options, [__a1,__a2,__a3,__a4,__a5,__a6,__a7,__a8,__a9,__a10,
                                                      __b1,__b2,__b3,__b4,__b5,__b6,__b7,__b8,__b9,__b10]),                
  _undet_xi 		   : assoc('xi,options, __a1*_x + __a2*_y + __a3 + __a4*_x^2 + __a5*_y^2 + __a6*_x*_y + __a7*_x^3 + __a8*_x*_y^2 + __a9*_x^2*_y + __a10*_y^3),                
  _undet_eta		   : assoc('eta,options,__b1*_x + __b2*_y + __b3 + __b4*_x^2 + __b5*_y^2 + __b6*_x*_y + __b7*_x^3 + __b8*_x*_y^2 + __b9*_x^2*_y + __b10*_y^3),                

  method : false,
  dprint(5,"findsymmetries::start"),
  _rhs:ratsimp(_Q/_P),
  _phi : _rhs, 
  _ode : 'diff(_y,_x) = _phi,
  dprint(5,"rhs = ",_phi, " ",_y),

  /* first: check if phi contains unknown functions that depend on more than 2 variables and cannot be separated */
  _phi : trigsimp(_phi), /* sin^2 + cos^2 =1 */
  /*_phi : trigexpand(_phi),*/ /* sin(x+y) = sin(x)cos(y) + sin(y)cos(x)*/
  dprint(5,"expr = ",_phi),
 
  /* no user defined functions that depend on x,y */
  /* if we do not call the routine from ode1Solve, then udf_args is not defined, we just set it as an empty list */
  if not listp(_udf_args) then _udf_args:[],
  _freefunctions_xy : sublist(_udf_args,lambda([_i],not freeof(_x,_i) and not freeof(_y,_i)   )),
  
  dprint(5,"free functions = ",_freefunctions_xy),

  if _freefunctions_xy=[] then (

  /* ***** y' = f(y) ***** */
  if useMethod="all" or useMethod="fy" or useMethod="quadrature" then (

    dprint(2,"   trying y' = F(y) ..."),  

    /* first, substitute dependencies */
    substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_phi),
    substlist: map("=",_varlist,_udf_args),
    _expr : subst(substlist,_expr),

    if freeof(_x,_expr) then (
       dprint(2,"*** solution found : y' = F(y) (quadrature) ***"),  
       method: "F(y)",
       _xi : 1, _eta : 0,
       return([_xi,_eta])
    )
  ),


  /* ************************** */
  /* ***** y' = f(x)      ***** */
  /* ***** quadrature     ***** */
  /* ************************** */
  if useMethod="all" or useMethod="fx" or useMethod="quadrature" then (

    dprint(2,"   trying y' = F(x) ..."),  

    /* first, substitute dependencies */
    substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_phi),
    substlist: map("=",_varlist,_udf_args),
    _expr : subst(substlist,_expr),

    if freeof(_y,_expr) then (
       dprint(2,"*** solution found : y' = F(x) (quadrature) ***"),  
       method: "F(x)",
       _xi:0, _eta:1,
       return([_xi,_eta])
    )
  ),

  /* ************************** */
  /* ***** separable      ***** */
  /* ***** y' = f(x)*g(y) ***** */
  /* ************************** */
  if useMethod="all" or useMethod="separable" then (

    dprint(2,"   trying y' = f(x)*g(y) ..."), 

    /* first, substitute dependencies */
    substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_phi),
    substlist: map("=",_varlist,_udf_args),
    _expr : subst(substlist,_expr),
    dprint(5,"separable, phi=",_expr),

    fg : separable(_expr,_x,_y), 

    if (fg#false) then (
      dprint(2,"*** solution found : y' = f(x)*g(y) (separable) ***"),  
      method: "separable",
      _xi : 1/fg[1], _eta : 0,
      return([_xi,_eta])
    )
  ),

  /* ************************** */
  /* ***** exact ode      ***** */
  /* ************************** */
  if useMethod="all" or useMethod="exact" then (
    dprint(2,"   trying exact ..."), 
    /* we first try the canonical expression of the ode */
    _expr : diff(_P,_x)+diff(_Q,_y),
    _expr : simplify(_expr), 
    if (_expr=0) then (
      dprint(2,"*** solution found : exact ***"),
      method:"exact",
      _xi:1/_Q, _eta:0,
      return([_xi,_eta])
    )
    /* TODO we should also test the original ode for exactness (not written in the form y'=f(x,y) but a(x,y)y'=b(x,y)) */

  ), 

  /* ********************************** */
  /* ***** linear first order ode ***** */
  /* ***** y' = g(x)*y + f(x)     ***** */
  /* ********************************** */
  if useMethod="all" or useMethod="linear" then (
    dprint(2,"   trying linear ..."),  

    /* first, substitute dependencies */
    /* linearp works with freeof, so does not work with dependencies */
    substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_phi),
    substlist: map("=",_varlist,_udf_args),
    _expr : subst(substlist,_expr),

    linearconstants:linearp(ratexpand(_expr),_y),
    dprint(4,"linearconstants = ",linearconstants),
    if linearconstants # false then (
      _f: rhs(linearconstants[1]), 
      _g: rhs(linearconstants[2]), 
      /* ----- y' = f(x) ----- */
      /* this case is already covered in the case separable */
      if _g=0 then (
        dprint(2,"*** solution found : y' = f(x) (linear) ***"),  
        method: "linear",
        _xi:0, 
        _eta:1 
      ) else  
      /* ----- y' = g(x)*y ----- */
      if _f=0 then (
        dprint(4,"*** solution found : y' = g(x)*y (linear) ***"),  
        method: "linear",
        _xi:0, 
        _eta:_y  
      ) else ( 
        /* ----- y' = f(x) + g(x)*y (general linear ode) ----- */
        dprint(2,"*** solution found : y' = f(x)+g(x)*y (linear) ***"),  
        method: "linear",
        /* symmetry generators for linear eq */
        _xi : 0,
        _eta: exp(integrate(_g,_x))
      ),
      dprint(4,"returning ",_xi,", ",_eta),  
      return([_xi,_eta])
    ) 
  ),

  /* ********************************* */
  /* ***** trying inverse-linear ***** */
  /* ********************************* */
  if useMethod="all" or useMethod="inverse-linear" then (
    dprint(2,"   trying inverse linear ..."), 

    /* first, substitute dependencies */
    substlist: map("=",map(op,dependencies),dependencies),
    _expr : subst(substlist,_phi),
    substlist: map("=",_varlist,_udf_args),
    _expr : subst(substlist,_expr),


    _phistar : simplify(1/sublis([_x=_y,_y=_x],_expr)),
    dprint(5,"  phi = ",_phistar), 
    
    linearconstants:linearp(ratexpand(_phistar),_y),
    if linearconstants # false then (
      _f: rhs(linearconstants[1]), 
      _g: rhs(linearconstants[2]), 
      /* ----- y' = f(x)*y ----- */
      if _f=0 then (
        dprint(4,"y' = 1/g(y)*x"),  
        method: "inverse-linear",
        _xi:sublis([_x=_y,_y=_x],_y), 
        _eta:0 
      ) else ( 
        /* ----- y' = f(x) + g(x)*y (general linear ode) ----- */
        dprint(2,"*** solution found : y' = 1/(f(y)+g(y)*x) (inverse-linear) ***"),  
        method: "inverse-linear",
        /* symmetry generators for linear eq */
        _xi: sublis([_x=_y,_y=_x],exp(integrate(_g,_x))),
        _eta : 0
      ),
      return([_xi,_eta])
    )
  ),

  /* ***************************************************** */
  /* ***** trying Bernoulli ode: y' = c1*y^c2 + c3*y ***** */
  /* ***************************************************** */
  if useMethod="all" or useMethod="bernoulli" or useMethod="Bernoulli" then (
    dprint(2,"   trying Bernoulli ..."),  
    _C : isBernoulli(_phi,_y,_x),
    dprint(5,"bernoulli = ",_C),
    if _C#false then (
      dprint(2,"*** solution found : y' = c1*y^c2 + c3*y (Bernoulli) ***"),  
      method: "bernoulli",
      [_xi,_eta]: [0, simplify(_y^_C[2] * exp((1-_C[2])*integrate(_C[3],_x)))],  
      return([_xi,_eta])
    )
  ),



  /* ***************************************************** */
  /* ***** trying Riccati ode: y' = a*y^2 + b*y + c ***** */
  /* TODO: some Riccati odes can be easily solved by transforming to bernoulli ... */
  /* TODO: some special riccati odes can be solved for defined coefficients        */
  /* ***************************************************** */
  if useMethod="all" or useMethod="riccati" or useMethod="Riccati" then (
    dprint(2,"   trying Riccati ..."),  
    _C : isRiccati(_phi,_y),
    if _C#false then (
      /* throw away quadratures */
      if not(freeof(_x,[_f0,_f1,_f2])) and _f0#0 and _f2#0 then (
        dprint(4,"C = ",_C),
        /* step 1: check if the chini invariant is constant. we can solve these directly */
        /* see kolokolnikov */
        _I : (diff(_f0,_x)*_f2 - _f0*diff(_f2,_x) - 2*_f0*_f1*_f2)^2 / (_f0*_f2)^3,
        _I : simplify(_I),
        dprint(3,"Riccati solver: Chini invariant I = ",_I),
        if freeof(_x,_I) and freeof(_y,_I) then (
          [_xi,_eta]: [simplify(sqrt(_f2/_f0)/_f2), simplify(_y*(diff(_f0,_x)*_f2 - _f0*diff(_f2,_x))/(2*_f0*_f0*_f2*sqrt(_f2/_f0)))],
          dprint(2,"*** solution found : y' = a*y^2 + b*y+c (Riccati, constant invariant) ***"),  
          method: "riccati-constant-invariant",
          return([_xi,_eta])
        ),
        /* other, simple methods: see if it transforms to a Bernoulli ode: */
        /* y' = c*y^2 + f(x)*y -f'(x) */
        /* y' = y*(c*y+f(x)) - f'(x)  */ 
        /* use the transformation u=y+f(x)/c */
        /* transforms to u' = c*u^2 - c*f(x)*u */
        _res : simplify(diff(1 + (_f1/_f2),_x) + _f0),
        dprint(4,"_res=",_res),
        if _res=0 then (
          dprint(2,"*** solution found : riccati maps to bernoulli ***"),
          depends(_u,_x),
          _bernoulliode : subst(y=1*_u - (_f1/_f2),_ode),
          _bernoulliode : ev(_bernoulliode,nouns),
          _bernoulliode : solve(_bernoulliode,diff(_u,_x))[1],
          dprint(4,"bernoulli ode : ",_bernoulliode),
          [_xi,_eta]: [0, simplify(_u^2 * exp((-1)*integrate(-(_f1),_x)))],         
          dprint(4,"xi,eta=",_xi,_eta),
          remove(_u,dependency),
          _res : checkSymmetries([_xi,_eta],_bernoulliode,_u,_x),

          /* now transform back to riccati using backtransform u=y+_f1*/ 
          [_xi,_eta] : simplify(subst(_u=_y+(_f1/_f2),[_xi,_eta])),
          dprint(4,"xi,eta=",_xi,_eta),
          method: "riccati-maps-to-bernoulli",
          return([_xi,_eta])

        )
      )
    )
  ),


  /* ***************************************************** */
  /* ***** trying Abel ode: y' = a*y^3 + b*y^2 + c*y + d ***** */
  /* we do not call abel by default because all constant invariant cases are solved by linear symmetries*/
  /* ***************************************************** */
  if useMethod="abel" or useMethod="Abel" then (
    dprint(2,"   trying Abel ..."),  
    _C : isAbel(_ode,_y,_x),
    if _C#false then (
      _C : ODE1_AbelSolve(_ode,_y,_x),
      if (_C=false) then (
        dprint(4,"Abel ode could not be solved (non-constant invariant)")
        /*return([false,"Abel nonconstant invariant"]) */
      ) else (
        dprint(2,"*** solution found : y' = a*y^3 + b*y^2+cy + d (Abel) ***"),  
        dprint(4,"Abel"),
        /*method: "Abel",*/
        [_xi,_eta] : _C,
        return([_xi,_eta])
     )
    )
  )


  /* ***** trying Chini ode: y' = a*y^n + b*y + c = 0 ***** */
  /* TODO: should test for generalized Abel instead */
  /* these are also solved by linear symmetries */
/*
  if useMethod="all" or useMethod="chini" or useMethod="Chini" then (
    dprint(4,"   trying Chini ..."),  
    dprint(4,"   WARNING NOT TESTED YET !!! ..."),  
    C : isChini(_ode,_y),
    if C#false then (
      C : ODE1_SolveChini(_ode,_y,_x),
      if (C=false) then (
        dprint(4,"Chini ode could not be solved (non-constant invariant)"),
        return([false,"Chini nonconstant invariant"]) 
      ),
      dprint(4,"y' = a*y^n + by + c (Chini)"),  
      dprint(4,"Chini"),
      method: "Chini",
      [_xi,_eta] : C,
      return([_xi,_eta])
    )
  )
*/
),  /* end of part where phi cannot have functions depending on both x and y */

dprint(5,"method = ",useMethod),

  /* ***** Cheb-Terrab and Roche 4.1,4.2,4.3 ***** */
  /* compute some simple symmetries (using Cheb-terrab and Roche) */
  if useMethod="all" or useMethod="symmetry1" or useMethod="symmetry2" or useMethod="symmetry3" then (
    dprint(2,"   trying simple symmetries ..."),  

    /* ***** Cheb-Terrab and Roche 4.1 - 4.3 ***** */
    _S : ode1_SimpleSymmetries(_phi,_y,_x,'useMethod=useMethod),
    dprint(5,"   S = ",_S),  
    if (_S # false) then (
      _xi : _S[1],
      _eta : _S[2],
      return([_xi,_eta])
    )
  ),

  if useMethod="all" or useMethod="symmetry4" then (
  /* ***** Cheb-Terrab and Roche 4.4 ***** */

  /* ***** [xi,eta] = [F(x), G(y)] ***** */
  /* first try the 'non-general' case */
  dprint(2,"   trying [xi,eta]=[F(x),G(y)] (non-general)"), 
  _S : false, 
  dprint(5,"_phi = ",_phi),
  /* _freefunctions is the list of free functions with declared dependencies */
  dprint(5,"free functions = ",_freefunctions),
  
  /* in freefunctions, we keep a list of all functions that depend on x and y */
  /* if there are functions that depend on both x and y, we can continue      */
  lf : sublist(_freefunctions,lambda([_i], diff(_i,_x)#0 and diff(_i,_y)#0)),

    dprint(5,"_Fnew=",_freefunctions), 
    dprint(5,"_F_args=",_F_args), 
    dprint(5,"lf=",lf), 


  dprint(5,"lf = ",lf),
  /* if lf#[] then the expression can not be separable */
  _symfound:false, 
  for l in lf do (

    dprint(5,"l = ",l),
    dprint(5,"dldx = ",diff(l,_x)),
    dprint(5,"dldy = ",diff(l,_y)),

      _fx_over_gy : simplify(diff(l,_x)/diff(l,_y)),
      dprint(5,"fx/gy = ",_fx_over_gy), 


      /* 1. first check for the non-separable case */
      dprint(5,"checking non-separable case (1)"),
      _xi : -1/_fx_over_gy,
      _eta : 1,      
      _res : checkSymmetries([_xi,_eta],'diff(y,x)=_phi,_y,_x),
      dprint(5,"det = ",_res), 
      if _res=0 then return(_symfound:true),

      /* 1. first check for the non-separable case */
      dprint(5,"checking non-separable case (2)"),
      _xi : 1,
      _eta : -_fx_over_gy,
      _res : checkSymmetries([_xi,_eta],'diff(y,x)=_phi,_y,_x),
      dprint(5,"det = ",_res), 
      if _res=0 then return(_symfound:true),
      
      /* if not a symmetry, then continue */
      dprint(5,"checking separability of ",_fx_over_gy), 
      _S : separable(1/_fx_over_gy,_x,_y),
      dprint(5,"_S = ",_S),
      if _S # false then (
        _xi : _S[1],
        _eta : -1/_S[2],
        _res : checkSymmetries([_xi,_eta],'diff(y,x)=_phi,_y,_x),
        dprint(5,"det = ",_res), 
        if _res=0 then return(_symfound:true),
 
        _xi : -_S[2],
        _eta : 1/_S[1],
        _res : checkSymmetries([_xi,_eta],'diff(y,x)=_phi,_y,_x),
        dprint(5,"det = ",_res), 
        if _res=0 then return(_symfound:true),

        dprint(1,"warning: could not find symmetry even though function was found")
        /*return(false)*/
      )
  ),
  if _symfound=true then ( 
    dprint(2,"*** solution found : [xi,eta]=[F(x),G(y)] not general ***"),  
    method: "[xi,eta]=[F(x),G(x)] not general",
    return([_xi,_eta])
  ) 
),

  /* ***** [xi,eta] = [F(x), G(y)] ***** */
  /* we do not use this method except for testing purposes */
  if useMethod="symmetry4b" then (

  dprint(2,"   trying [xi,eta]=[F(x),G(y)] (general)"), 
  /* we can improve further by demanding that the functions are of the form K(f(x)+g(y))*/
  /* */
 
  dprint(4,"   trying [xi,eta]=[F(x),G(y)] (general)"), 
    lf : sublist(_freefunctions,lambda([_i], diff(_i,_x)#0 and diff(_i,_y)#0)),
    dprint(5,"lf=",lf), 

  if lf # [] then (
    _logphi : (log(_phi)),
    _logphi_x : (diff(_logphi,_x)),
    _logphi_y : (diff(_logphi,_y)),
    A : simplify(diff(_logphi,_x,1,_y,1)),
    dprint(5,"A = ",A),
    if A=0 then return([false]),
    B : simplify(diff(_logphi,_y,2) + diff(_logphi,_y)^2),
    dprint(5,"B = ",B),
    if B=0 then return([false]),
    C : simplify(diff(_logphi,_x,2) - diff(_logphi,_x)^2),
    if C=0 then (dprint(5,"C is zero, no 4.4 symmetry!",A,B,C),return([false])),
    Ax : (diff(A,_x)), 
    Ay : (diff(A,_y)),
    Axy :(diff(Ax,_y)),
    Axx : (diff(Ax,_x)), 
    Ayy : (diff(Ay,_y)),
    D : (2*Axy + _logphi_x*Ay - Ax*_logphi_y + A*(_logphi_x*_logphi_y+2*A))*A - 3*Ax*Ay,
    D : simplify(D),

    if D=0 then (
      dprint(4,"case 1"),

      E1 : simplify(3*Ax^2 + ((_logphi_x^2+2*C)*A - 2*Axx)*A),
        dprint(5,"E1 = ",E1),
      if E1=0 then return([false]),
      E2 : simplify((2*Ayy + (2*B-_logphi_y^2)*A)*A - 3*Ay^2),
        dprint(5,"E2 = ",E2),
      if E2#0 then return([false]),
      E3 : simplify(((28*Ax + 4*_logphi_x*A)*A^3 - (_logphi_y*A + Ay)*E1)*E1 - 8*A^4*diff(E1,_x)),
      dprint(5,"E3 = ",E3),
      if E3#0 then return([false]), 
        dprint(4,"D=0,[xi,eta]=[F(x),G(y)]"),  
        method: "D=0,[xi,eta]=[F(x),G(y)]",
        _eta : exp(integrate((4*(Ax-_logphi_x*A)*A^3 + (_logphi_y*A-Ay)*E1)/(2*A*E1),_y)),
        _xi : -4 * A^3*_eta / E1,
        return ([simplify(_xi),simplify(_eta)]) 
      
    ) else (
      dprint(4,"case 2"),
      Dx : simplify(diff(D,_x)),
      dprint(5,"Dx = ",Dx),
      dprint(4,"case II, Dx = ",Dx),
      Dy : simplify(diff(D,_y)),
      dprint(5,"Dy = ",Dy),
      _expr : ((6*Ax*Ayy*D) + 
     (6*Ax*D*B - 3*_logphi_y^2*Ax*D - 2*Ayy*Dx + (_logphi_y^2*Dx - 2*Dx*B)*A)*A)*A
     + ((3*A*Dx-9*Ax*D)*Ay-3*D^2)*Ay + A*Dy*D,
     _expr: simplify(_expr),
      dprint(5,"expr = ",_expr),
      if (_expr=0) then (
        E4 : simplify((2*Ayy + (2*B-_logphi_y^2)*A)*A - 3*Ay^2),
        dprint(5,"E4 = ",grind(E4)),
        if E4=0 then return([false]),
        E5 : simplify(4*A^3*D - D^2 + ((2*Axx-(_logphi_x^2+2*C)*A)*A - 3*Ax^2)*E4),
        dprint(5,"E5 = ",E5),
        if E5#0 then return([false]),
        E6 : simplify(-A*diff(E4,_y)*D +((diff(E4,_x)-_logphi_y*D)*A+3*Ay*D+(A*_logphi_x-3*Ax)*E4)*E4),
        dprint(5,"E6 = ",E6),
        if E6#0 then return([false]), 
          method: "D#0,[xi,eta]=[F(x),G(y)]",
          _eta : exp(integrate(simplify(((A*_logphi_x-Ax)*E4-(Ay+A*_logphi_y)*D)/(2*A*D)),_y)),
          _xi : simplify(-E4*_eta/D),
          return ([_xi,_eta]) 
      )
    )
  )
),


  if useMethod="all" or useMethod="symmetry5" then (
    /* ***** Cheb-Terrab and Roche 4.5 ***** */
    /* ----- [xi,eta] = [ax+by+c, fx+gy+h] ----- */
    dprint(2,"   trying [xi,eta]=[ax+by+c,fx+gy+h]"),  

    /*_X : methodOfUndeterminedCoefficients(_phi,_y,_x), */
    _X : methodOfUndeterminedCoefficients(_phi,_y,_x,'varlist=_undet_var,'xi=_undet_xi,'eta=_undet_eta), 
    if _X#false then (
      
      dprint(2,"*** solution found : [xi,eta]=[ax+by+c,fx+gy+h] (symmetry5) ***"),  
      method: "[ax+by+c,fx+gy+h]",
      [_xi,_eta]:_X,
      _res : simplify(_eta - _xi*_phi),
      if (_res=0) then (
        dprint(1,"warning: symmetry found but it was trivial")
      ) else  
        return([_xi,_eta])
    )
  ),

  if useMethod="all" or useMethod="symmetry6" then (
    /* ***** Cheb-Terrab and Kolokolnikov ***** */
    /* ----- [xi,eta] = [F(x),P(x)*y+Q(x) ] ----- */
    dprint(2,"   trying [xi,eta]=[F(x),P(x)y+Q(x)]"),  
    _X : linearSymmetries(_odeCanonical,_y,_x),
    if _X#false then (
      dprint(2,"*** solution found : [xi,eta]=[F(x),P(x)y+Q(x)] (symmetry6) ***"),  
      method: "[F(x),P(x)y+Q(x)]",
      [_xi,_eta]:_X, 
      return([_xi,_eta])
    )
  ),


  dprint(5,"end of Lie symmetry search"),
  /* we return a second item in the list, which is the reason it failed ("failed","Riccati","Abel") */
  return([false,"failed"])
)$ 
/* ************************************************************************** */



/* ************************************************************************** */
/* ************************************************************************** */
/* ************************************************************************** */
ode1_SimpleSymmetries(_phi,_y,_x,[options]):=block([_S,_F,_G,_H,_xi,_eta,_expr,_Gy,_Fxx,_FxplusGy,_freefunctions_xy,_Phi_x,_Phi_y,_Phi_yy,_Q,_Q_x,_Q_y,_Psi,_A,_B,_res],

  useMethod              : assoc('useMethod,options,"all"),               /* these are methods symmetry1, symmetry2, symmetry3 */

  /* no user defined functions that depend on x,y */
  _freefunctions_xy : sublist(_udf_args,lambda([_i],not freeof(_x,_i) and not freeof(_y,_i)   )),
  _freefunctions_gdf : sublist(_gdf_args,lambda([_i],not freeof(_x,_i) and not freeof(_y,_i)   )),
  dprint(5,"   freefunctions = ",_freefunctions_xy),  
  

  if _freefunctions_xy = [] then (

  /* ***** Cheb-Terrab and Roche 4.1 ***** */
  /* ***** [xi,eta] = [F(x)*G(y), 0] ***** */
  if useMethod="all" or useMethod="symmetry1" then (
    dprint(4,"   trying [xi,eta]=[F(x)*G(y),0]"),  
    dprint(5,"   phi = ",_phi),  
    /* note, if S=0 then the original ode is separable */
    _S : simplify(diff(log(_phi),_x,1,_y,1)/_phi^2),
    if (_S=0) then (dprint(1,"warning, ode is separable, returning false (please solve using method=separable)"),return(false)),
    dprint(5,"   S = ",_S),  
    dprint(5,"calling separable"), 
    _S : separable(_S,_x,_y),
    dprint(5,"   S = ",_S),  
    if _S # false then (
      _F: _S[1],
      _G: _F * diff(1/(_F*_phi),_x),
      _G : simplify(_G), 
      dprint(1,"warning, _G (should be free of x) = ",_G),
      if freeof(_x,_G) then (
        _G : exp(integrate(_G,_y)),
        dprint(2,"*** solution found : [xi,eta]=[F(x)*G(y),0] (symmetry1) ***"),  
        method: "[xi,eta]=[F(x)*G(y),0]",
        _xi : simplify(_F*_G),
        _eta : 0,
        return([_xi,_eta])
      )
    )
  ),

  /* ***** Cheb-Terrab and Roche 4.2 ***** */
  /* ***** [xi,eta] = [F(x)+G(y), 0] ***** */

  if useMethod="all" or useMethod="symmetry2" then (
    dprint(4,"   trying [xi,eta]=[F(x)+G(y),0]"),  
    dprint(5,"   phi = ",_phi), 
    if _freefunctions_xy#[] or _freefunctions_gdf#[] then (
      dprint(5,"found function with inseparable part, no symmetries of type symmetry2: ",_freefunctions_xy," ",_freefunctions_gdf)
    ) else ( 
      _expr :  simplify(_phi * diff(1/_phi,_x,2)), /* eq.27 */
      /* note, if expr=0 then the ode is inverse-linear*/
      dprint(5,"   expr = ",_expr), 

      if (_expr=0) then (dprint(1,"warning: ode is (inverse)-linear, returning false (please solve using method=inverse-linear)"),return(false)),

      _S : diff(1/_expr,_y),
      if _S=0 then(dprint(1,"warning, S=0, ode is probably directly separable or inverse-linear. returning false"), return(false)),
    
      dprint(5,"   _S = ",_S),  
      _S : separable(_S,_x,_y),
      dprint(5,"   _S = ",_S),  
      if _S # false then (
        _Gy : _S[2], 
        dprint(5,"Gy=",_Gy),
        _Fxx : 1/_S[1],
        dprint(5,"Fxx=",_Fxx),
        /* if S[1]=1, then we do not have an Fxx */
        _FxplusGy : _Fxx/_expr,
        dprint(5,"Fx+Gy=",_FxplusGy),
        _expr : diff(_FxplusGy*_phi,_x) + _phi*_phi*diff(_FxplusGy,_y),
        dprint(5," expr will now be simplified, ",_expr), 
        _expr : simplify(_expr),
        dprint(5," simplified expression, ",_expr), 

        if _expr=0 then (
          dprint(2,"*** solution found : [xi,eta]=[F(x)+G(y),0] (symmetry2) ***"),  
          method: "[xi,eta]=[F(x)+G(y),0]",
          _xi : _FxplusGy,
          _eta : 0,
          return([_xi,_eta])
        ) else (
          dprint(5,"symmetries are not compatible with determining equations"),
          dprint(5,"discarding symmetries")
        )
      )
    )
  ) 
  ),
 
  /* ***** Cheb-Terrab and Roche 4.3 ***** */
  /* ***** [xi,eta] = [F(x), H(x)]   ***** */
  if useMethod="all" or useMethod="symmetry3" then (
    dprint(4,"   trying [xi,eta]=[F(x),H(x)]"), 

    /* the first thing we can do is check if the right hand side can be split into */ 
    /* phi = f(x) + g(x,y) */
    /* this will immediately cancel out kamke1.80, which takes 10 minutes to simplify */
    /* we can also check if we have general functions f(y) */
 
    _Phi_y : diff(_phi,_y),
      dprint(5,"phi_y = ",_Phi_y),
    _Phi_yy : simplify(diff(_Phi_y,_y)), /* we need this to check if phi_yy=0*/
      dprint(5,"phi_yy = ",_Phi_yy),
    if _Phi_yy#0 then (
      _Q : simplify(_Phi_y/_Phi_yy),
      dprint(5,"Q = ",_Q),
      
      _Q_y : diff(_Q,_y),
      dprint(5,"Qy = ",_Q_y),
      _Q_y : simplify(_Q_y),
      dprint(5,"simplified Qy = ",_Q_y),

      if (_Q_y # 0) then (
        _Q_x : diff(_Q,_x),
        _Psi : simplify(_Q_x/_Q_y),

        dprint(4,"psi = ",_Psi),
        if freeof(_y,_Psi) then (
          _Phi_x : diff(_phi,_x),
          _expr : (_Psi*_Phi_y - diff(_Psi,_x) - _Phi_x)/(_phi+_Psi),

          _expr : simplify(_expr),

          dprint(4,"expr = ",_expr),
          if freeof(_y,_expr) then (
            dprint(4,"found symmetry"),
            _F : simplify(exp(integrate(_expr,_x))),
            _H : simplify((-_Psi * _F)),

            dprint(2,"*** solution found : Qy#0, [xi,eta]=[F(x),G(x)] (symmetry3) ***"),  
            method: "Qy#0, [xi,eta]=[F(x),G(x)]",
            _xi : _F,
            _eta : _H,
            return ([_xi,_eta]) 
          ) 
        )
      ) else (
        /* odes of the type y'=A(x)+B(x)*exp(y/C1) */
        _res : AplusBF(ratexpand(_phi),_x,_y),
        dprint(5,"res=",_res),
        if _res#false then (        
          _A : rhs(_res[4]),
          dprint(5,"A=",_A),
          _B : rhs(_res[3]),
          dprint(5,"B=",_B),
 
          _B : separable(_B,_x,_y),
          if _B#false then (
            _B : _B[1],
            dprint(5,"B=",_B),
            _F : simplify(exp(-integrate(_A/_Q,_x))/_B),
            dprint(5,"F=",_F),
            _H : simplify(_A * _F),    
            dprint(5,"H=",_H),
            dprint(2,"*** solution found : Qy=0,[xi,eta]=[F(x),G(x)] (symmetry3) ***"),  
            method: "Qy=0,[xi,eta]=[F(x),G(x)]",
            _xi : _F,
            _eta : _H,
            return ([_xi,_eta]) 
          )
        )  
      )
    )
  ),

return(false)
)$


/* ************************************************************************* */
/* ***** print expr only when flag<DEBUGFLAG                           ***** */
/* ************************************************************************* */
dprint(flag,[expr])::= if flag <= DEBUGFLAG then buildq ([expr], print (splice (expr)));
/* ************************************************************************* */


/* ************************************************************************* */
/* ***** change variables x and y to get the reverse ode dx/dy = f(y,x) **** */
/* ************************************************************************* */
reverseODE1(ode,y,x):=block([reverseode],
  /* sublis does a parallel substitution*/
  reverseode : sublis([x=y,y=x],ode),
  reverseode : solve(reverseode,'diff(y,x)), 
  dprint(5,"reverse ode = ",reverseode),
  return(reverseode)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* splits an expression containing square roots and factorizes the            */
/* square roots such that                                                     */
/*   sqrt((p1*p2*...pn)/(q1*q2*..qm))                                         */
/*   = sqrt(p1)*sqrt(p2)*...sqrt(pn)/(sqrt(q1)*sqrt(q2)*..sqrt(qm))           */
/* this is the inverse of rootscontract                                       */
/* ************************************************************************** */
rootsexpand(expr) :=block([splitExpr:expr,freeof_i:false,sqrtList,insideSqrtList,factorsInsideSqrtList,splitSqrtList,_X,_L,_i],
  if not(freeof(sqrt,dispform(expr,all))) then (
    dprint(4,"trying to split square root terms"),
    if freeof(%i,expr) then ( 
      dprint(4,"expression is free of imaginary numbers"),
      freeof_i : true
    ),
    /* get a list with all the sqrt terms */
    sqrtList:sublist(showratvars(expr),lambda([_x],not(freeof(sqrt,dispform(_x,all))))),
    insideSqrtList : flatten(map(args,sqrtList)),
    dprint(5,"insidesqrtlist:",insideSqrtList), 
    factorsInsideSqrtList:map(factor_list,insideSqrtList),
    
    /* at this point, we might have -1 as a factor. we should remove it and switch sign to the second term */
    _i:1,
    for _L in factorsInsideSqrtList do (
    if _L[1] = -1 then (_L:rest(_L), _L[1]:-_L[1],factorsInsideSqrtList[_i]:_L),
    _i : _i+1 
    ),
 
 
    dprint(5,"factorsinsidesqrtlist:",factorsInsideSqrtList), 
    factorsInsideSqrtList:map(sqrt,factorsInsideSqrtList),
    dprint(5,"factorsinsidesqrtlist:",factorsInsideSqrtList), 

    splitSqrtList:[],
    for _L in factorsInsideSqrtList do (  
     _X : 1,
     for _i in _L do _X:_X*_i,
     splitSqrtList : endcons(first(sqrtList) = _X,splitSqrtList),   
     sqrtList : rest(sqrtList)
    ),
    splitExpr : subst(splitSqrtList,expr)
  ), 
  dprint(5,"expr: ",splitExpr), 
  dprint(5,"freeof: ",is(freeof_i=true)), 

  /* do not introduce imaginary numbers */
  if (freeof_i=true) and (freeof(%i,splitExpr)=false) then (
    dprint(0,"we have introduced imaginary numbers in expr: ",splitExpr), 
    return(expr) 
  )
  else
    return(ratsimp(splitExpr))
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* returns factors as lists (Stavros Macrakis) */
/* ************************************************************************** */
factor_list(ex):=
  if mapatom(ex) then [ex] else            /* don't factor numbers */
    block([fex: factor(ex),inflag:true],
          if mapatom(fex) or op(fex)#"*" then [fex]
	  else args(fex)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ----- simple method of finding the constant factor in front of an equation */
/* step 1: construct a set of args(expr)                                      */
/* step 2: determine the subset containing only constants                     */
/* ************************************************************************** */
constant_factors(_expr,_varlist) := block([inflag:true,_constantfactors:1,_oldratvars,_substlist],

  /* first, substitute dependencies */
  _substlist: map("=",map(op,dependencies),dependencies),
  _expr : subst(_substlist,_expr),

  if not(listp(_varlist)) then _varlist : [_varlist],

  _oldratvars : ratvars,
  ratvars : _varlist, /* this was done globally elsewhere, should we do it only locally? */
  _expr : ratsimp(_expr),

  if lfreeof(_varlist,_expr) then
    _constantfactors:_expr
  else if not mapatom(_expr) and op(_expr)="*"
  /* we know that the internal dependent variable is _x,and we want expr to be free of x */
  /* constantp doesn't knowthat abs(a) is constant */
  then
    _constantfactors : xreduce("*",listify(subset(setify(args(_expr)),lambda([_u],lfreeof(_varlist,_u))))),

  ratvars : _oldratvars,

  return(_constantfactors)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** give determining equations for first order ode                 ***** */
/* ************************************************************************** */
determiningEquations(_ode,_y,_x):=block([_phi,_eta,_xi,_n,_deteq],
  depends(_eta,[_x,_y]),
  depends(_xi,[_x,_y]),
  _ode: ode1CanonicalForm(_ode,_y,_x),
   
  _phi    : rhs(_ode),
  dprint(4,"phi=",_phi),
  _deteq: diff(_eta,_x) + (diff(_eta,_y) - diff(_xi,_x))*_phi - diff(_xi,_y)*_phi^2 - _xi*diff(_phi,_x) - _eta*diff(_phi,_y),
  _deteq : simplify(_deteq),
  dprint(4,"determining equation = ",_deteq),


  remove(_xi,dependency),remove(_eta,dependency),

  return(_deteq)
)$

/* ************************************************************************** */
/* ***** determine a symmetry of the form [xi,eta]=[ax+by+c, fx+gy+h]   ***** */
/* ************************************************************************** */
methodOfUndeterminedCoefficients(_phi,_y,_x,[options]):=block([determiningEquation,L,L2,__a1,__a2,__a3,__a4,__a5,__a6,__a7,__a8,__a9,__a10,__b1,__b2,__b3,__b4,__b5,__b6,__b7,__b8,__b9,__b10,__c,__d,__e,__f,__g,__h,_i,eq1,eq2,l,C,found,_op,_args,_xi,_eta,_var],


  /* --- check all the optional arguments --- */
  _var		   : assoc('varlist,options, [__a1,__a2,__a3,__a4,__a5,__a6,__a7,__a8,__a9,__a10,__b1,__b2,__b3,__b4,__b5,__b6,__b7,__b8,__b9,__b10]),                
  _xi 		   : assoc('xi,options, __a1*_x + __a2*_y + __a3 + __a4*_x^2 + __a5*_y^2 + __a6*_x*_y + __a7*_x^3 + __a8*_x*_y^2 + __a9*_x^2*_y + __a10*_y^3),                
  _eta		   : assoc('eta,options,__b1*_x + __b2*_y + __b3 + __b4*_x^2 + __b5*_y^2 + __b6*_x*_y + __b7*_x^3 + __b8*_x*_y^2 + __b9*_x^2*_y + __b10*_y^3),                

  dprint(5,"xi = ",_xi),
  dprint(5,"eta = ",_eta),
 
  determiningEquation : diff(_eta,_x) + (diff(_eta,_y)-diff(_xi,_x))*_phi - diff(_xi,_y)*_phi^2 - _xi*diff(_phi,_x) - _eta*diff(_phi,_y),
  dprint(5,"determining equation = ",grind(determiningEquation)),
  determiningEquation: simplify(determiningEquation),

  /* subterms with terms like sqrt(f+g)/(fg+f^2) are not simplified, except with factor */
  _op : op(ratexpand(determiningEquation)),
  _args : args(ratexpand(determiningEquation)),
  determiningEquation : apply(_op,map(factor,_args)),    

  dprint(5,"determining equation = ",grind(determiningEquation)),
  /* for some equations, ratsimp hangs*/
  /*L : args(ratexpand(ratsimp(determiningEquation))),*/
  L : args(ratexpand((determiningEquation))),
  dprint(5,"L = ",L),
  L2 : [],

  /* we write the determining equation as C1*f1(x,y) + C2*f2(x,y) + ... , and we put the terms in a list */
  for l in L do ( 
    C:constant_factors(l,[_x,_y]), 
    L2:endcons([C,ratsimp(l/C)],L2)
  ),
  dprint(5,"L2 = ",L2),

  eq1:[],
  eq2:[],
  while L2#[] do (
    l:first(L2), 
    /*dprint(5,"term = ",l), */
    _i:0,
    found:false,
    /*dprint(5,found),*/
    for eq in eq2 do (
      _i:_i+1, 
      if eq=l[2] then (
        eq1[_i]:eq1[_i]+l[1],/*dprint(5,_i," eq1=",eq1),*/
        found:true
        /*dprint(5,"found a term: ",eq)*/
      )
    ),    
    if found=false then (
      /*dprint(5,"adding a term",l[1],", ",l[2]), */
      eq1:endcons(l[1],eq1),/*dprint(5,"eq1=",eq1),*/
      eq2:endcons(l[2],eq2) /*,dprint(5,"eq2=",eq2)*/
    ), 

  L2 : delete(l,L2) 
  ),

  dprint(5,"eqs = ",grind(eq1)),
  dprint(5,"vars = ",grind(_var)),
  sol:solve(eq1,_var),
  dprint(4,"solution=",sol),
  for _r in %rnum_list do sol:subst(1,_r,sol),
  dprint(4,"solution=",sol),
  if sol=[] then return(false),

  _xi : subst(sol,_xi),
  _eta : subst(sol,_eta),
  dprint(5,"xi = ",_xi),
  dprint(5,"eta = ",_eta),
  if _xi=0 and _eta=0 then return(false),

  dprint(5,"solution = ",sol),
  return([_xi,_eta])
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* detects if expr is the right-hand side of a Riccati equation */
/* ************************************************************************** */
isRiccati(_expr,_y):=block( [_a,_b,_c],
  /* first, check if the expression is f/g. if it is, we return false */
  /* ... */

  ratexpand(_expr),
  return(riccatip(_expr,_y))
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* change of variables of an ode  TODO */
/* ************************************************************************** */
dchange(ode,expr):=block([],

return(false)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** convert first order Riccati ode to second order linear ode     ***** */
/* TODO: make this Riccati2Linear*/
/* ************************************************************************** */
Riccati2SecondOrder(ode,y,x):=block([newode],
  newode:ratexpand(ev(subst(y=diff(v(x),x)/v(x),ode),nouns)),
  newode : solve(newode,diff(v(x),x,2)),
  return(newode)
)$
/* convert second order linear ode to first order Riccati ode */
/* secondOrder2Riccati(expr,y,x) */
/* ... */



/* ************************************************************************** */
/* ***** try some symmetries for implicit odes                          ***** */
/* ************************************************************************** */
ODE1_implicit(ode,_y,_x):=block([
List_Sym:[[0,_y],[0,_x],
          [0,1/_x],[0,1/_y],
          [_x,0],[_y,0],
          [1/_x,0],[1/_y,0],
          [_x,_y],[_y,_x] ]

],

  /* loop over symmetries and see if one of them is a symmetry of ode*/
  for sym in List_Sym do(
    if checkSymmetries(sym,ode,_y,_x)=0 then return(sym) 
  ),
  return(false)
)$
/* ************************************************************************** */


/* ************************************************************************** */
/* ***** find a gcd that does not depend on the variables               ***** */
/* ***** input: two expressions c1*f(x,y) and c2*g(x,y)                 ***** */
/* ***** output: largest common constant                                ***** */
/* ************************************************************************** */
greatest_constant_divisor(_F,_G,varlist):=block([_c1,_c2,_C],
  
   _c1 : constant_factors(ratsimp(_F),varlist),
   _c2 : constant_factors(ratsimp(_G),varlist),
   _C : gcd(_c1,_c2), 
   /* do not use op because op fails on atoms, e.g. op(5) fails */ 
   if signum(_F)=-1 and signum(_G)=-1 then _C:-_C,
   return(_C)
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* copy from ode2.mac */
/* ************************************************************************** */
/*block(local(soln,xc,yc),*/
  ic1(soln,xc,yc):= block([stringC,lC,listC,%C,%%C],
    stringC:string(integration_constant),
    lC:slength(stringC),
    /*print("stringC=",stringC),*/
    /*print("lC=",lC),*/
     (
       noteqn(xc), 
       noteqn(yc), 
       /*boundtest('integration_constant,integration_constant), */
       listC:delete(lhs(yc),delete(lhs(xc),showratvars(soln))), 
       /*print("list=",listC), */
       for _S in listC do(
         /*print("S=",_S), */
         if slength(string(_S))>=lC then
           if substring(string(_S),1,lC+1)=stringC then %C:_S
       ),
       /*boundtest('%C,), */
       /*print("%C=",%C),*/
       %%C:%C, 
       /*sol:rhs(solve(at(soln,[xc,yc]),%C)[1]),*/
       /*print("sol=",sol),print("%%C=",%%C),*/
       ratsimp(subst([%%C=rhs(solve(at(soln,[xc,yc]),%C)[1])],soln))
     )

/*  )*/
)$

/* ************************************************************************** */
/*block(local(x),*/
 noteqn(x):=if atom(x) or not inpart(x,0)="="
              then (disp(x), disp("boundary condition is not an equation"), error()
)$
 
/* ************************************************************************** */
 /*block(local(x,y),*/
 boundtest(x,y):=
    if x#y then (disp(x), disp("constant of integration must not be bound"), error()
)$
/* ************************************************************************** */

/* ************************************************************************** */
/* ***** compute differential invariants from symmetries                ***** */
/* ***** compute here differential invariants of first order odes only  ***** */
/* ************************************************************************** */
/* a general routine would generate differential invariants of order n*/
differentialInvariants(_X,_y,_x):=block([_eta,_xi],

_xi : _X[1],
_eta : _X[2],
/* first prolongation of eta: */
dy : xxx,
_eta1 : diff(_eta,_x) + (diff(_eta,_y) - diff(_xi,_x))*dy - diff(_xi,_y)*dy^2,

/* Xr=0*/
if _xi=0 and _eta=0 then return(false),

if _xi#0 then (ode: 'diff(y,x)=_eta/_xi,_Y:y,_X:x) else (ode:'diff(x,y)=_xi,_eta, _Y:x,_X:y),

/* compute first fundamental differential invariant: dx/xi = dy/eta */
sol : ode1Solve(ode,_Y,_X,'returnSymmetries=false,'returnIntegratingFactor=false,'returnSolution=true)

/* compute second fundamental differential invariant dy/eta = dy1/deta1 */


)$




/* ************************************************************************** */
/* tests for abel subroutine */
/* bernoulli equation */
/* ************************************************************************** */
Bernoulliode:'diff(y,x)+a*y^3 + b*y;
/* kamke1[204]*/


kol230:'diff(y,x)=(x^3*y^4 + 4*x^4*y^3+6*x^5*y^2+4*x^6*y+x^7)*(x^a+1)-y/x-2$

/* ode from cheb-terrab, eq.22  */
/* example of [xi,eta] = [F(x)*G(y),0]*/
/* [xi,eta] = [(x+a)^2 * exp(-1/(y+b)),0]*/
/* time: 1.0 - 2.2 s*/
/* 07/12 0.7 s */
ode22:'diff(y,x)=-(y+b)^2/((x+a)*(1+(y+b)^2*(x+a)*sin(y)))$

/* [xi,eta] = [0, (y^2+x^2)/(2x^2*y^2)] */
/* time : 3-5 s*/
/* 07/12 0.8 s */
ode32:'diff(y,x)=3*(1+x^2/y^2)*atan(y/x)+(1-2*y)/x + (1-3*y)*x/y^2$

/* [xi,eta] = [(x^2+y^2)/(2x^2y^2),0]*/
/* time: 1-2 s*/
/* 07/12 1.15 s*/
ode33:'diff(y,x)=y*x^2/(3*y*(x^2+y^2)*atan(x/y)+y^2*(1-3*x)+x^2*(1-2*x))$

/* example of an ode with symmetry [xi,eta]=[f(x),g(x] */
/* [xi,eta] = [1,-a/b]*/
/* time: 0.1 - 0.4 s*/
/* 07/12 0.04 s*/
ode55:'diff(y,x)=f(a*x+b*y)$

/* example of an ode with symmetry [xi,eta]=[f(y),g(y] */
/* [xi*,eta*] = [x^2,x^2], [xi,eta] = [y^2,y^2] */
/* time: 56 s*/
/* 07/12 4.5-5.2 s*/
ode58:'diff(y,x)=y^2/(sin(y-x)-x^2+2*x*y)$

/* example of an ode with symmetry [xi,eta]=[f(x),g(y] */
/* [xi,eta] = [x^(1-a),-y^(1-b)]*/
/* 07/12 2.1 s*/
ode66:'diff(y,x)=x^(a-1)*y^(1-b)*f(x^a/a+y^b/b)$

/* example of an ode with symmetry [xi,eta]=[ax+by+c,dx+ey+f] */
/* [xi,eta] = [x,y*(m+1)] */
/* time: 50-70 s*/
/* 07/12 42 s*/
ode93:'diff(y,x)=(a*y^n+b*x^(n*(m+1)))/x^(n*(m+1)-m)$
/* */

/*
times:[];N:10;FAILED:0;SUCCESS:0;for i:1 thru N do (
print("********** i = ",i,"/",N," **********"),
t1:elapsed_run_time(),
RESULT:ODE1_LieSolve(kamke1[i],y,x),
times:endcons([elapsed_run_time()-t1,RESULT],times),
if RESULT=false then FAILED:FAILED+1 else SUCCESS:SUCCESS+1,
print("time = ",times),
print("********** **********")
);print("SUCCESS=",SUCCESS,"/",N,", FAILED=",FAILED,"/",N);print("timings:",times);
*/

/*
times:[];N:48;FAILED:0;SUCCESS:0;for i:1 thru N do (
print("********** i = ",i,"/",N," **********"),
t1:elapsed_run_time(),
RESULT:AbelNormalForm(kamke1[i],y,x),
if RESULT#false then times:endcons([i, RESULT,checkSymmetries(RESULT,kamke1[i],y,x)],times),
if RESULT=false then FAILED:FAILED+1 else SUCCESS:SUCCESS+1,
print("********** **********")
);print("SUCCESS=",SUCCESS,"/",N,", FAILED=",FAILED,"/",N);print("timings:",times);
*/


/*

times:[];N:10;start:1;FAILED:0;SUCCESS:0;for i:start thru (start+N-1) do (
   print("********** i = ",i+1-start,"/",N," **********"),
   t1:elapsed_run_time(),
   RESULT:ode1Solve(kamke1[i],y,x,'useMethod="abel"),
   t:elapsed_run_time()-t1,
   if RESULT[1]#false then times:endcons([i, RESULT,checkSymmetries(RESULT,kamke1[i],y,x),method,t],times),
   if RESULT[1]=false then (FAILED:FAILED+1, times:endcons([i,RESULT,t],times) ) else SUCCESS:SUCCESS+1,
print("********** **********")
);print("timings:",times);print("SUCCESS=",SUCCESS,"/",N,", FAILED=",FAILED,"/",N);

*/
/* get list of equations only 

L:sublist(times,lambda([e],freeof(false,e)));
makelist(L[i][1],i,length(L));
*/

/*
DEBUGFLAG:5;times:[];totaltime:0;N:100;start:101;FAILED:0;SUCCESS:0;for i:start thru (start+N-1) do (
   print("********** i = ",i+1-start,"/",N," **********"),
   t1:elapsed_run_time(),
   RESULT:ode1Solve(kamke1[i],y,x,'useMethod="symmetry1"),
   t:elapsed_run_time()-t1, totaltime:totaltime+t,
   if RESULT[1]#false then times:endcons([i, RESULT,checkSymmetries(RESULT,kamke1[i],y,x),method,t],times),
   if RESULT[1]=false then (FAILED:FAILED+1, times:endcons([i,RESULT,t],times) ) else SUCCESS:SUCCESS+1,
print("********** **********")
);printf(true,"~{~{~a ~}~%~}",times);print("SUCCESS=",SUCCESS,"/",N,", FAILED=",FAILED,"/",N);print("total time = ",totaltime," seconds");

*/
